<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2010-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 header.html - Header file used to customize the headers on each HTML page for the API 
               Interface Specification documents.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1.
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support Rev E Alpha process using Doxygen 1.8.2 -->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Multicore Asynchronous Runtime Environment Synchronous Data-Flow (SDF)</title><!--END !PROJECT_NAME-->
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multicore Asynchronous Runtime Environment
   &#160;<span id="projectnumber">HT80-NG608-1 E</span>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-QCOM -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="revision_history.html"><span>Revision&#160;History</span></a></li>
      <li><a href="introduction.html"><span>Introduction</span></a></li>
      <li><a href="usergroup0.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="usergroup1.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup3.html"><span>Tutorials</span></a></li>
      <li><a href="usergroup4.html"><span>Reference&#160;Manual</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sdf.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Synchronous Data-Flow (SDF) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The MARE SDF API supports the Synchronous Data-Flow graph (SDF) programming model. The SDF API allows the programmer to describe a graph of compute nodes that are connected with streaming data channels. The programmer associates a C++ node-function with each node, and specifies a basic C++ type or a user-defined data-type for each channel. Once launched, the graph executes synchronously, i.e., the nodes execute in lock-step, and at every step each channel has exactly one element pushed and one element popped (in FIFO order). Hence, SDF executes as a sequence of graph iterations. Note the contrast with the standard synchronous dataflow model where a node needs to pop/push a constant number of elements from a channel in each graph iteration, not exactly one element as required by MARE SDF. With MARE SDF, the user can create a channel that carries multiple data items wrapped as a single data item, to gain equivalency with the general synchronous dataflow case.</p>
<h1><a class="anchor" id="sdfforme"></a>
Is MARE SDF for me?</h1>
<p>Like the MARE API for tasks, the SDF API is intended for easy integration into C++ applications. It is meant to ease the programmer's burden with regards to the correct and efficient orchestration of a collection of work specified by the programmer.</p>
<p>Application work that is repeated many times with the same control-flow or data-flow structure is a good candidate for execution via SDF. Applications from Computer Vision and Gaming tend to structure computation into frames, where the high-level compute structure every frame is often fixed. Additionally, an application component within a single frame may execute by applying the same structure of computation to a sequence of data, such as processing image data in segments. SDF can be applied at multiple levels in a such a situation: a graph for the frame and a graph implementing a component of the frame graph. The component graph would run multiple iterations for each iteration of the frame graph. In this situation, the SDF API allows the creation of all the graphs upfront, avoiding the creation overheads of the component graph every frame. The component graph can simply be paused at the end of each frame, and resumed at the start of the next frame.</p>
<p>Algorithms from signal processing can also be expected to map in a straightforward manner to SDF.</p>
<h1><a class="anchor" id="sdffeatures"></a>
Features</h1>
<p>The MARE SDF API is designed with the following intent.</p>
<p>1. The SDF graph is created dynamically by a C++ program. Though once launched the graph can no longer be modified.</p>
<p>2. The SDF graph allows arbitrary C++ code in a node-function, though the parameter list of a node-function is dictated by the channels connected to the corresponding node.</p>
<p>3. The streaming data channels can transport any data-type that is shallow-copyable, i.e., a <code>memcpy()</code> should suffice for transporting the data from a producer node to a consumer.</p>
<p>4. The SDF semantics are automatically enforced via the API in the following ways.</p>
<ul>
<li><em>Iteration ordering</em>: a node executes graph iteration i+1 only after the node has completed iteration i.</li>
</ul>
<ul>
<li><em>Implicit channel access</em>: the input channels of a node are each popped once before the node executes, and the output channels are each pushed once after the node completes. The node-function parameter list provides access by-reference to the inputs and outputs. The user-code cannot perform any explicit pop or push operations.</li>
</ul>
<ul>
<li><em>Precise pause-resume and cancel semantics</em>, built around the notion of SDF graph iterations. The user can specify if the interruptions (pause or cancel) occur at graph iteration boundaries, or should occur ASAP even if different nodes execute a different number of iterations. Here the user can choose between precise semantics or the low latency application of an interruption request. Additionally, the user can specify the minimum number of iterations that must be completed before the interruption is applied.</li>
</ul>
<p>5. The SDF runtime performs automatic optimizations, including pipeline parallelization and lowered scheduling overheads, based on the fixed structure of the graph.</p>
<p>6. SDF does not restrict the user from mixing in other C++ paradigms, including other parallel programming constructs, such as mutexes on global shared data. <a class="el" href="sdf.html#sdfmixingparadigms">Mixing other C++ paradigms with SDF</a> describes how some common paradigms mix with SDF for greater benefit.</p>
<h1><a class="anchor" id="sdfexample"></a>
Example 1: A simple pipeline</h1>
<p>The following code implements a graph with the pipeline structure shown below.</p>
<pre class="fragment">    dc1        dc2
A -------&gt; B -------&gt; C
</pre><p>Nodes A, B, C are connected using channels dc1 and dc2. dc1 and dc2 carry values of type <code>int</code>. The graph will execute 10 iterations, resulting in the data structure <code>vresults</code> containing 10 integers. The nodes A, B and C execute the node-function assigned to them when each node was created. In this example, all the node-functions are C++11 lambdas, but they could be regular C/C++ functions, among other options. Note that the parameter list of each lambda matches the number and data-types of the channels connected to the node corresponding to that lambda. The MARE runtime invokes each node-function 10 times during the graph execution, corresponding to the 10 graph iterations requested. Values are streamed from A to B via dc1 and from B to C via dc2.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vresults;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__sdf__doc.html#classmare_1_1data__channel">mare::data_channel&lt;int&gt;</a>  dc1, dc2;</div>
<div class="line"></div>
<div class="line">mare::sdf_graph_ptr g = <a class="code" href="group__sdf__doc.html#ga9d04a6f4b558cbc80fe9cd54aa5e6dbf">mare::create_sdf_graph</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> counter = 0;</div>
<div class="line"><span class="comment">// Node A</span></div>
<div class="line"><a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">mare::create_sdf_node</a>(g,</div>
<div class="line">                      [&amp;](<span class="keywordtype">int</span>&amp; output)</div>
<div class="line">                      {</div>
<div class="line">                        output = counter++;</div>
<div class="line">                      },</div>
<div class="line">                      <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">mare::with_outputs</a>(dc1));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Node B</span></div>
<div class="line"><a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">mare::create_sdf_node</a>(g,</div>
<div class="line">                      [](<span class="keywordtype">int</span>&amp; input, <span class="keywordtype">int</span>&amp; output)</div>
<div class="line">                      {</div>
<div class="line">                        output = input * 2;</div>
<div class="line">                      },</div>
<div class="line">                      <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">mare::with_inputs</a>(dc1),</div>
<div class="line">                      <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">mare::with_outputs</a>(dc2));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Node C</span></div>
<div class="line"><a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">mare::create_sdf_node</a>(g,</div>
<div class="line">                      [&amp;](<span class="keywordtype">int</span>&amp; input)</div>
<div class="line">                      {</div>
<div class="line">                        vresults.push_back(input);</div>
<div class="line">                      },</div>
<div class="line">                      <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">mare::with_inputs</a>(dc2));</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> std::size_t num_iterations = 10;</div>
<div class="line"><a class="code" href="group__sdf__doc.html#gacf9359313b799b03561c860d41b1ba7c">mare::launch_and_wait</a>(g, num_iterations);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__sdf__doc.html#ga575be6357d0a6eff6570efa0b0ba2cf3">mare::destroy_sdf_graph</a>(g);</div>
</div><!-- fragment --><h1><a class="anchor" id="sdffilter"></a>
Example 2: Filter graph with feedback edges</h1>
<p>The following graph illustrates a filter with feedback edges implemented using MARE SDF.</p>
<pre class="fragment">         d1         d3         d4         d6          d7
      x ----&gt; add1 ----&gt; mult ----&gt; add2 ----&gt; split ----&gt; y
               ^                     ^          | |
            d2 |                  d5 |          | |
               |                     |----D-----| |
               |                                  |
               |--------D--------D----------------|
</pre><p>The "D"'s represent iteration delays along edges. For example, edge <code>d2</code> takes the value <code>y</code> produced at end of iteration <code>i</code> and presents it to be added to the value of <code>x</code> at the start of iteration <code>i+2</code> (since there are two "D"'s along the edge <code>d2</code>).</p>
<p><code>filter()</code> applies an IIR filter to a sequence of values in <code>x_arr</code> and produces a sequence of filtered results in <code>y_arr</code>. The edges in the graph become streaming channels in MARE SDF.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> filter(<span class="keywordtype">float</span> x_arr[], <span class="keywordtype">float</span> y_arr[], <span class="keywordtype">int</span> N, <span class="keywordtype">float</span> coeff) {</div>
<div class="line">  <span class="keyword">using namespace </span>mare;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel&lt;float&gt;</a> d1, d2, d3, d4, d5, d6, d7;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> g = <a class="code" href="group__sdf__doc.html#ga9d04a6f4b558cbc80fe9cd54aa5e6dbf">create_sdf_graph</a>();</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> x_index = 0;</div>
<div class="line">  <span class="keywordtype">int</span> y_index = 0;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Reads an input data item x in each iteration</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g, [&amp;](<span class="keywordtype">float</span>&amp; x) { x = x_arr[x_index++]; },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs</a>(d1));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// add1: adds x to the filter output from two iterations ago</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g, [](<span class="keywordtype">float</span>&amp; in1, <span class="keywordtype">float</span>&amp; in2, <span class="keywordtype">float</span>&amp; out) { out = in1 + in2; },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs</a>(d1, d2), <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs</a>(d3));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// mult: multiply by a fixed coefficient</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g, [=](<span class="keywordtype">float</span>&amp; in, <span class="keywordtype">float</span>&amp; out) { out = coeff * in; },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs</a>(d3), <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs</a>(d4));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// add2: adds the intermediate data to the filter output from one iteration ago</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g, [](<span class="keywordtype">float</span>&amp; in1, <span class="keywordtype">float</span>&amp; in2, <span class="keywordtype">float</span>&amp; out) { out = in1 + in2; },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs</a>(d4, d5), <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs</a>(d6));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// splits the adder output into y and the two feedback edges</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g,</div>
<div class="line">                  [](<span class="keywordtype">float</span>&amp; in, <span class="keywordtype">float</span>&amp; out1, <span class="keywordtype">float</span>&amp; out2, <span class="keywordtype">float</span>&amp; out3)</div>
<div class="line">                  {</div>
<div class="line">                    out1 = out2 = out3 = in;</div>
<div class="line">                  },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs</a>(d6), <a class="code" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs</a>(d2, d5, d7));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Writes a filtered output in each iteration</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node</a>(g, [&amp;](<span class="keywordtype">float</span>&amp; in) { y_arr[y_index++] = in; },</div>
<div class="line">                  <a class="code" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs</a>(d7));</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Add two delays to d2</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel</a>(d2, std::vector&lt;float&gt;{0.0, 0.0});</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Add one delay to d5</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel</a>(d5, std::vector&lt;float&gt;{0.0});</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Stream N data items through graph</span></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#gacf9359313b799b03561c860d41b1ba7c">launch_and_wait</a>(g, N);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="group__sdf__doc.html#ga575be6357d0a6eff6570efa0b0ba2cf3">destroy_sdf_graph</a>(g);</div>
<div class="line">}</div>
</div><!-- fragment --><p>All channels in MARE SDF are single-source and single-destination. Note the use of an explicit splitter node when one output value is consumed by multiple source nodes along multiple channels. Here, the values carried by <code>dc6</code> are split by a node by repetition along channels <code>dc2, dc5</code> and <code>dc7</code>. Instead of having the add followed by a split, the user could have alternatively defined a combined "add-and-split" node that replicated the sum on three output channels.</p>
<p>The <code><a class="el" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel()</a></code> function adds delays to channels. A certain number of initial values are pre-loaded into the channel. The number of initial values introduce that many delays along the channel. The initial values will be consumed first (by channel pops in the early graph iterations) while new values get pushed in FIFO order.</p>
<p>Any cycle in a synchronous dataflow graph must have at least one delay on an edge in the cycle. Otherwise, the graph is not a valid synchronous dataflow graph. At launch time, MARE SDF analyzes the graph for optimal execution. Improper SDF graphs are detected during this analysis at launch, producing a runtime error before the graph commences execution. Examples of improper graphs include:</p>
<ul>
<li>a channel connected to a node at only one end (dangling channel)</li>
<li>a graph cycle with no delays along any of its channels</li>
</ul>
<h1><a class="anchor" id="sdfmixingparadigms"></a>
Mixing other C++ paradigms with SDF</h1>
<p>The following constructs provide functionality that SDF does not attempt to duplicate. These constructs can be inter-mixed with SDF with the usual care associated with such constructs and a minimal understanding of the SDF semantics provided above in <a class="el" href="sdf.html#sdffeatures">Features</a>.</p>
<ul>
<li><em>Global variables</em>: node-functions can access global variables. Global variables might provide shared read-only data for the node-functions, though the data could be freely modified by the application when the graph is paused. Or, a node-function may exclusively update global data not shared with other node-functions (e.g., a source node reading from a global file-pointer and feeding data into the graph).</li>
</ul>
<ul>
<li><em>Mutexes, conditional-wait signalling</em>: A node-function may access shared state protected by mutexes. The user must be cognizant of the SDF semantics about the serialization imposed on a node by the iteration ordering (node n may execute iteration i+1 only after node n has executed iteration i). The dependence structure of the graph may further constrain node n2 to execute iteration i only after a predecessor node n has executed iteration i. Apart from these restrictions, SDF may execute nodes concurrently for the same iteration i, and may have executions of multiple iterations (iterations ...,i-1, i, i+1, i+2, ...) in flight at the same time for different parts of the graph. Care must be taken if the user intends to perform conditional-waits across SDF nodes in the same graph, as deadlocks can occur due to the order of execution chosen by SDF. The user should ensure that the wait-signalling nodes are chosen so that they are guaranteed to be executed by SDF in a safe order based on the SDF semantics. Note: consider using <code><a class="el" href="group__sync.html#classmare_1_1mutex">mare::mutex</a></code> and <code><a class="el" href="group__sync.html#classmare_1_1condition__variable">mare::condition_variable</a></code> instead of the C++ Standard library variants, as these allow the MARE runtime to become aware of blocked work and better schedule work across cores.</li>
</ul>
<ul>
<li><em>Callable objects to manage state</em>: Callable objects can impart state to node-functions, avoiding a reliance on global state. Additionally, the callable object may implement methods that provide consistent interfaces for both the node-function and the external application to access the object data (say, locking a mutex to guard data that may be concurrently accessed).</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2012-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 footer.html - footer file used to customize the footers on each HTML page for the API 
               Interface Specification documents.
 Updated:  11/05/13 LB Removed confidential, distribution, and export statement.
 Updated:  09/20/13 LB Updated to support mare project's User Guide and API doc.
 Updated:  04/18/13 LB Added Documentation and Interface Specification in place of hard-coding doc dcn. Deleted original
                       use of Documentation and Interface Specification to display text in the left portion of the footer.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1
 Updated:  01/18/13 LB Replaced qualcomm_logo.gif to QTI_Logo.png
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support the Rev E Alpha Doxygen-to-HTML-PDF process. -->
<!-- start footer part -->
<!-- 7/12/12 JG added div class defined in css to include warning statement on all pages -->
<!--[if lte IE 8]><div class="warningmsgie8"><![endif]-->
<!--[if(gte IE 9)|!(IE)]><!--><div class="warningmsg"><!--<![endif]-->
</div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="userguide.html">User Guide</a></li><li class="navelem"><a class="el" href="patterns.html">Parallel Programming Patterns</a></li>
    <li class="footer">
		<p align="right">HT80-NG608-1 E<br />
        <img class="footer"  alt="QTI Logo" src="qti_logo_HTML.png" />
		</p>
		</li>
  </ul>
</div>
</body>
</html>
