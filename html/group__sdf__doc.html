<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2010-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 header.html - Header file used to customize the headers on each HTML page for the API 
               Interface Specification documents.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1.
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support Rev E Alpha process using Doxygen 1.8.2 -->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Multicore Asynchronous Runtime Environment Synchronous Dataflow</title><!--END !PROJECT_NAME-->
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multicore Asynchronous Runtime Environment
   &#160;<span id="projectnumber">HT80-NG608-1 E</span>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-QCOM -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="revision_history.html"><span>Revision&#160;History</span></a></li>
      <li><a href="introduction.html"><span>Introduction</span></a></li>
      <li><a href="usergroup0.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="usergroup1.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup3.html"><span>Tutorials</span></a></li>
      <li><a href="usergroup4.html"><span>Reference&#160;Manual</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sdf__doc.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Synchronous Dataflow<div class="ingroups"><a class="el" href="group__chapter__patterns__doc.html">Patterns Reference API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Using the patterns defined in this chapter requires including the following header file: </p>
<pre class="fragment">    #include &lt;mare/sdf.hh&gt;</pre> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classmare_1_1channel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#classmare_1_1channel">mare::channel</a></td></tr>
<tr class="separator:classmare_1_1channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classmare_1_1data__channel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">mare::data_channel&lt; T &gt;</a></td></tr>
<tr class="separator:classmare_1_1data__channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classmare_1_1sdf__graph__query__info"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">mare::sdf_graph_query_info</a></td></tr>
<tr class="separator:classmare_1_1sdf__graph__query__info"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classmare_1_1node__channels"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">mare::node_channels</a></td></tr>
<tr class="separator:classmare_1_1node__channels"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga25383b6ec53acd5ad739f159cd85863f"><td class="memItemLeft" align="right" valign="top">typedef std::tuple<br class="typebreak"/>
&lt; internal::direction, channel * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga25383b6ec53acd5ad739f159cd85863f">mare::tuple_dir_channel</a></td></tr>
<tr class="separator:ga25383b6ec53acd5ad739f159cd85863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga94c0b95e227ce2a63f0df4f6b6dbb44a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga94c0b95e227ce2a63f0df4f6b6dbb44a">mare::sdf_interrupt_type</a> { <b>undef</b>, 
<b>iter_non_synced</b>, 
<b>iter_synced</b>
 }</td></tr>
<tr class="separator:ga94c0b95e227ce2a63f0df4f6b6dbb44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga87ae4b477aa7816a538450bae55ed297"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Trange &gt; </td></tr>
<tr class="memitem:ga87ae4b477aa7816a538450bae55ed297"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">mare::preload_channel</a> (data_channel&lt; T &gt; &amp;dc, Trange const &amp;tr)</td></tr>
<tr class="separator:ga87ae4b477aa7816a538450bae55ed297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d04a6f4b558cbc80fe9cd54aa5e6dbf"><td class="memItemLeft" align="right" valign="top">sdf_graph_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga9d04a6f4b558cbc80fe9cd54aa5e6dbf">mare::create_sdf_graph</a> ()</td></tr>
<tr class="separator:ga9d04a6f4b558cbc80fe9cd54aa5e6dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575be6357d0a6eff6570efa0b0ba2cf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga575be6357d0a6eff6570efa0b0ba2cf3">mare::destroy_sdf_graph</a> (sdf_graph_ptr &amp;g)</td></tr>
<tr class="separator:ga575be6357d0a6eff6570efa0b0ba2cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2edf34ad1ff554c95ca3f25e74e42382"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2edf34ad1ff554c95ca3f25e74e42382"><td class="memTemplItemLeft" align="right" valign="top">io_channels&lt; Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">mare::with_inputs</a> (data_channel&lt; Ts &gt; &amp;...dcs)</td></tr>
<tr class="separator:ga2edf34ad1ff554c95ca3f25e74e42382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa206ac31609f470885c041d223bb179"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa206ac31609f470885c041d223bb179"><td class="memTemplItemLeft" align="right" valign="top">io_channels&lt; Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">mare::with_outputs</a> (data_channel&lt; Ts &gt; &amp;...dcs)</td></tr>
<tr class="separator:gaaa206ac31609f470885c041d223bb179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba8cd1885e057f08a82c0cc6f5f8f5a"><td class="memTemplParams" colspan="2">template&lt;typename Body , typename... IOC_GROUPS&gt; </td></tr>
<tr class="memitem:gadba8cd1885e057f08a82c0cc6f5f8f5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; internal::is_MDCAW<br class="typebreak"/>
&lt; IOC_GROUPS...&gt;::value, <br class="typebreak"/>
sdf_node_ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">mare::create_sdf_node</a> (sdf_graph_ptr g, Body &amp;&amp;body, IOC_GROUPS const &amp;...io_channels_groups)</td></tr>
<tr class="separator:gadba8cd1885e057f08a82c0cc6f5f8f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb99ad11bf97101d95e5f794cad60881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gafb99ad11bf97101d95e5f794cad60881">mare::assign_cost</a> (sdf_node_ptr n, double execution_cost)</td></tr>
<tr class="separator:gafb99ad11bf97101d95e5f794cad60881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41492c16474885aaf1689d8d1976abd0"><td class="memItemLeft" align="right" valign="top">sdf_graph_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga41492c16474885aaf1689d8d1976abd0">mare::get_graph_ptr</a> (sdf_node_ptr node)</td></tr>
<tr class="separator:ga41492c16474885aaf1689d8d1976abd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9e3b36c636e8afd1ba7788a49a37592"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gac9e3b36c636e8afd1ba7788a49a37592">mare::get_debug_id</a> (sdf_node_ptr node)</td></tr>
<tr class="separator:gac9e3b36c636e8afd1ba7788a49a37592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9359313b799b03561c860d41b1ba7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gacf9359313b799b03561c860d41b1ba7c">mare::launch_and_wait</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:gacf9359313b799b03561c860d41b1ba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abec4f4cc3e3a5ab503ccbf230c9914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga7abec4f4cc3e3a5ab503ccbf230c9914">mare::launch_and_wait</a> (sdf_graph_ptr g, std::size_t num_iterations)</td></tr>
<tr class="separator:ga7abec4f4cc3e3a5ab503ccbf230c9914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d88ec9965da7eaa9da60ab7c27041b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:gaf6d88ec9965da7eaa9da60ab7c27041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga482b1499e18d1207b414eac4de554a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga482b1499e18d1207b414eac4de554a4f">mare::launch</a> (sdf_graph_ptr g, std::size_t num_iterations)</td></tr>
<tr class="separator:ga482b1499e18d1207b414eac4de554a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85399a8348917a0a0bb47d40bc5fd069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga85399a8348917a0a0bb47d40bc5fd069">mare::wait_for</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:ga85399a8348917a0a0bb47d40bc5fd069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d8af997cd2133796de15818de3c506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaa2d8af997cd2133796de15818de3c506">mare::cancel</a> (sdf_graph_ptr g, sdf_interrupt_type intr_type=sdf_interrupt_type::iter_non_synced)</td></tr>
<tr class="separator:gaa2d8af997cd2133796de15818de3c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9022fc00d748993ffd3f6a951b1a493b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga9022fc00d748993ffd3f6a951b1a493b">mare::cancel</a> (sdf_graph_ptr g, std::size_t desired_cancel_iteration, sdf_interrupt_type intr_type=sdf_interrupt_type::iter_non_synced)</td></tr>
<tr class="separator:ga9022fc00d748993ffd3f6a951b1a493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e722f0ab6dd94c7352bd26e7652c4b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">mare::pause</a> (sdf_graph_ptr g, sdf_interrupt_type intr_type=sdf_interrupt_type::iter_non_synced)</td></tr>
<tr class="separator:ga7e722f0ab6dd94c7352bd26e7652c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5508552d0d90d864f48e8ec418b44a8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga5508552d0d90d864f48e8ec418b44a8d">mare::pause</a> (sdf_graph_ptr g, std::size_t desired_pause_iteration, sdf_interrupt_type intr_type=sdf_interrupt_type::iter_non_synced)</td></tr>
<tr class="separator:ga5508552d0d90d864f48e8ec418b44a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb43e41f6c48947337241f6e3f9ecc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga4bb43e41f6c48947337241f6e3f9ecc7">mare::resume</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:ga4bb43e41f6c48947337241f6e3f9ecc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8679478ca1506a6c96b5953b3b64a20"><td class="memItemLeft" align="right" valign="top">sdf_graph_query_info&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gae8679478ca1506a6c96b5953b3b64a20">mare::sdf_graph_query</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:gae8679478ca1506a6c96b5953b3b64a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef753b805cc7e71c8926d9c730e80657"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaef753b805cc7e71c8926d9c730e80657">mare::to_string</a> (sdf_graph_query_info const &amp;info)</td></tr>
<tr class="separator:gaef753b805cc7e71c8926d9c730e80657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a79ddb2b738544bd3e09bef58dcaf9"><td class="memTemplParams" colspan="2">template&lt;typename OStream &gt; </td></tr>
<tr class="memitem:ga56a79ddb2b738544bd3e09bef58dcaf9"><td class="memTemplItemLeft" align="right" valign="top">OStream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga56a79ddb2b738544bd3e09bef58dcaf9">mare::operator&lt;&lt;</a> (OStream &amp;os, sdf_graph_query_info const &amp;info)</td></tr>
<tr class="separator:ga56a79ddb2b738544bd3e09bef58dcaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0276f6027b29e74dfa7826864792bf7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf0276f6027b29e74dfa7826864792bf7"><td class="memTemplItemLeft" align="right" valign="top">tuple_dir_channel&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaf0276f6027b29e74dfa7826864792bf7">mare::as_in_channel_tuple</a> (data_channel&lt; T &gt; &amp;dc)</td></tr>
<tr class="separator:gaf0276f6027b29e74dfa7826864792bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11ee6c728ca9ebc43e620cbecdd5485"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf11ee6c728ca9ebc43e620cbecdd5485"><td class="memTemplItemLeft" align="right" valign="top">tuple_dir_channel&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#gaf11ee6c728ca9ebc43e620cbecdd5485">mare::as_out_channel_tuple</a> (data_channel&lt; T &gt; &amp;dc)</td></tr>
<tr class="separator:gaf11ee6c728ca9ebc43e620cbecdd5485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed796590ccbf20e02c99a4ca6af9fdc"><td class="memItemLeft" align="right" valign="top">sdf_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga7ed796590ccbf20e02c99a4ca6af9fdc">mare::create_sdf_node</a> (sdf_graph_ptr g, void(*body)(node_channels &amp;), std::vector&lt; tuple_dir_channel &gt; &amp;v_dir_channels)</td></tr>
<tr class="separator:ga7ed796590ccbf20e02c99a4ca6af9fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873b621dfc5a63fd354cef670e7464b5"><td class="memTemplParams" colspan="2">template&lt;typename Body &gt; </td></tr>
<tr class="memitem:ga873b621dfc5a63fd354cef670e7464b5"><td class="memTemplItemLeft" align="right" valign="top">sdf_node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ga873b621dfc5a63fd354cef670e7464b5">mare::create_sdf_node</a> (sdf_graph_ptr g, Body &amp;&amp;body, std::vector&lt; tuple_dir_channel &gt; &amp;v_dir_channels)</td></tr>
<tr class="separator:ga873b621dfc5a63fd354cef670e7464b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classmare_1_1channel" id="classmare_1_1channel"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class mare::channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base class representing a channel connection between two SDF nodes.</p>
<p>Cannot be instantiated directly by user. User code must instantiate the derived class <code>data_channel&lt;T&gt;</code> to create a channel carrying elements of user-defined-type <code>T</code>.</p>
<p>However, user code can pass pointers of the base type <code>channel*</code> and use those to connect SDF nodes instead of the templated <code>data_channel&lt;T&gt;</code>. This is useful for the programmatic construction of an SDF graph, where the number and user-data-types of channels connected to a node may not be fixed at compile-time: specialized user code may create typed data_channels, while generic user code may only use <code>channel*</code> to connect the graph.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a> </dd></dl>

<p>Definition at line <a class="el" href="channel_8hh_source.html#l00040">40</a> of file <a class="el" href="channel_8hh_source.html">channel.hh</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public member functions</h3></td></tr>
<tr class="memitem:a05621779077b105b5724663ad1f808a5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a05621779077b105b5724663ad1f808a5">get_elem_size</a> () const </td></tr>
<tr class="separator:a05621779077b105b5724663ad1f808a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Member Functions</h3></td></tr>
<tr class="memitem:a47784423741ae8681211dfb108c85466"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47784423741ae8681211dfb108c85466"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> (std::size_t Tsize)</td></tr>
<tr class="separator:a47784423741ae8681211dfb108c85466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private member functions</h3></td></tr>
<tr class="memitem:a6bf2f4aeae44375b487ce1fe7c79eb60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bf2f4aeae44375b487ce1fe7c79eb60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a>(<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> const &amp;))</td></tr>
<tr class="separator:a6bf2f4aeae44375b487ce1fe7c79eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecc9e229ff7c3f80500be55147ba43e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ecc9e229ff7c3f80500be55147ba43e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a>(<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> &amp;&amp;))</td></tr>
<tr class="separator:a0ecc9e229ff7c3f80500be55147ba43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c7fc362f2ca75d778f33ddaf8f98cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39c7fc362f2ca75d778f33ddaf8f98cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> &amp;operator=(<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> const &amp;))</td></tr>
<tr class="separator:a39c7fc362f2ca75d778f33ddaf8f98cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb35f465964c306486576ff626c80b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb35f465964c306486576ff626c80b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> &amp;operator=(<a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> &amp;&amp;))</td></tr>
<tr class="separator:a4fb35f465964c306486576ff626c80b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a4968b24e7cd758f792bcc536e6e02679"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4968b24e7cd758f792bcc536e6e02679"></a>
internal::channel_internal_record *&#160;</td><td class="memItemRight" valign="bottom"><b>_cir</b></td></tr>
<tr class="separator:a4968b24e7cd758f792bcc536e6e02679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr class="memitem:a80512fc9f94a7c39a122111dc9dbb4a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80512fc9f94a7c39a122111dc9dbb4a1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>internal::channel_accessor</b></td></tr>
<tr class="separator:a80512fc9f94a7c39a122111dc9dbb4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a05621779077b105b5724663ad1f808a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::channel::get_elem_size </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>sizeof(T)</code> corresponding to the user-data-type <code>T</code> used to construct the channel <code>data_channel&lt;T&gt;</code>.</p>
<p>Provides some introspection or debugging capability to generic user-code when the application is divided into specialized user-code that creates <code>data_channel&lt;T&gt;</code>, but only <code>channel*</code> is passed to the generic user code.</p>
<dl class="section return"><dt>Returns</dt><dd><code>sizeof(T)</code> for <code>T</code> used in channel construction via <code>data_channel&lt;T&gt;</code> </dd></dl>

</div>
</div>

</div>
</div>
<a name="classmare_1_1data__channel" id="classmare_1_1data__channel"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class mare::data_channel</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class mare::data_channel&lt; T &gt;</h3>

<p>Construct a channel carrying elements of arbitrary user-data-type <code>T</code>.</p>
<p>A channel must be connected as input to exactly one SDF node and as output to exactly one SDF node (possibly the same, if "delays" are added on the channel), before the launch of a graph containing the nodes. Both nodes must belong to the same SDF graph.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a> the base class. </dd>
<dd>
<a class="el" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel()</a> for adding delays on a <a class="el" href="group__sdf__doc.html#classmare_1_1channel">channel</a>. </dd></dl>

<p>Definition at line <a class="el" href="channel_8hh_source.html#l00083">83</a> of file <a class="el" href="channel_8hh_source.html">channel.hh</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public member functions</h3></td></tr>
<tr class="memitem:a6a6e00fca9e84e9186d182899fe4133c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6e00fca9e84e9186d182899fe4133c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>(<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>&lt; T &gt; const &amp;))</td></tr>
<tr class="separator:a6a6e00fca9e84e9186d182899fe4133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39449b57dc4a10b5275fed53c18dda47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39449b57dc4a10b5275fed53c18dda47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>(<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>&lt; T &gt; &amp;&amp;))</td></tr>
<tr class="separator:a39449b57dc4a10b5275fed53c18dda47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ac98359338d113c9386b2d31cd470"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a277ac98359338d113c9386b2d31cd470"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a> &amp;operator=(<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>&lt; T &gt; const &amp;))</td></tr>
<tr class="separator:a277ac98359338d113c9386b2d31cd470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ecd8a6925a342735e40c2f07a2ea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a102ecd8a6925a342735e40c2f07a2ea5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MARE_DELETE_METHOD</b> (<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a> &amp;operator=(<a class="el" href="group__sdf__doc.html#classmare_1_1data__channel">data_channel</a>&lt; T &gt; &amp;&amp;))</td></tr>
<tr class="separator:a102ecd8a6925a342735e40c2f07a2ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__sdf__doc"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__sdf__doc')"><img src="closed.png" alt="-"/>&#160;Public member functions inherited from <a class="el" href="group__sdf__doc.html#classmare_1_1channel">mare::channel</a></td></tr>
<tr class="memitem:a05621779077b105b5724663ad1f808a5 inherit pub_methods_group__sdf__doc"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a05621779077b105b5724663ad1f808a5">get_elem_size</a> () const </td></tr>
<tr class="separator:a05621779077b105b5724663ad1f808a5 inherit pub_methods_group__sdf__doc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_group__sdf__doc"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_group__sdf__doc')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="group__sdf__doc.html#classmare_1_1channel">mare::channel</a></td></tr>
<tr class="memitem:a47784423741ae8681211dfb108c85466 inherit pro_methods_group__sdf__doc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47784423741ae8681211dfb108c85466"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> (std::size_t Tsize)</td></tr>
<tr class="separator:a47784423741ae8681211dfb108c85466 inherit pro_methods_group__sdf__doc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="classmare_1_1sdf__graph__query__info" id="classmare_1_1sdf__graph__query__info"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class mare::sdf_graph_query_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Query information about the state of an SDF graph.</p>
<p>Captures a sample of an SDF graph's execution state when <a class="el" href="group__sdf__doc.html#a6e863c7b1a74c02c642b4fb5e5fb5611">sdf_graph_query()</a> is used to query a graph's execution state.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#a6e863c7b1a74c02c642b4fb5e5fb5611">sdf_graph_query()</a> </dd>
<dd>
<a class="el" href="group__sdf__doc.html#a1bd85195bc697ae371cb9d571b5aa01c">to_string()</a> </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00490">490</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public member functions</h3></td></tr>
<tr class="memitem:ad6734ca9b6962775bcee5521bc376e84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#ad6734ca9b6962775bcee5521bc376e84">was_launched</a> () const </td></tr>
<tr class="separator:ad6734ca9b6962775bcee5521bc376e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5418d595ffa8584adff4c786224452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a3e5418d595ffa8584adff4c786224452">has_completed</a> () const </td></tr>
<tr class="separator:a3e5418d595ffa8584adff4c786224452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec655fd2b14fd17d83dbd67c43fb024b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#aec655fd2b14fd17d83dbd67c43fb024b">is_paused</a> () const </td></tr>
<tr class="separator:aec655fd2b14fd17d83dbd67c43fb024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7696c6b537cd850c9a3a6763561504db"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a7696c6b537cd850c9a3a6763561504db">current_min_iteration</a> () const </td></tr>
<tr class="separator:a7696c6b537cd850c9a3a6763561504db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bcc3455c9805e71a7244231191b049"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a21bcc3455c9805e71a7244231191b049">current_max_iteration</a> () const </td></tr>
<tr class="separator:a21bcc3455c9805e71a7244231191b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d6319b4fbb0947bcc2a6a9ff863e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdf__doc.html#ga94c0b95e227ce2a63f0df4f6b6dbb44a">sdf_interrupt_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a273d6319b4fbb0947bcc2a6a9ff863e5">intr_type</a> () const </td></tr>
<tr class="separator:a273d6319b4fbb0947bcc2a6a9ff863e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a71d38976b98fa05dc0dc72607b059460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71d38976b98fa05dc0dc72607b059460"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_was_launched</b></td></tr>
<tr class="separator:a71d38976b98fa05dc0dc72607b059460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6ae41384bbee8606598616309c637c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac6ae41384bbee8606598616309c637c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_has_completed</b></td></tr>
<tr class="separator:aac6ae41384bbee8606598616309c637c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8d893668dcf11a7e469d4ca0dec66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03d8d893668dcf11a7e469d4ca0dec66"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_is_paused</b></td></tr>
<tr class="separator:a03d8d893668dcf11a7e469d4ca0dec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0d122384b391108d83342601cefbb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0d122384b391108d83342601cefbb0"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_current_min_iteration</b></td></tr>
<tr class="separator:a2e0d122384b391108d83342601cefbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb04a5c5e35728e205f92b6b56535a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb04a5c5e35728e205f92b6b56535a2a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_current_max_iteration</b></td></tr>
<tr class="separator:afb04a5c5e35728e205f92b6b56535a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a2e4c345838792e3e5284bfc9e406"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720a2e4c345838792e3e5284bfc9e406"></a>
<a class="el" href="group__sdf__doc.html#ga94c0b95e227ce2a63f0df4f6b6dbb44a">sdf_interrupt_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_intr_type</b></td></tr>
<tr class="separator:a720a2e4c345838792e3e5284bfc9e406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr class="memitem:a6e863c7b1a74c02c642b4fb5e5fb5611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a6e863c7b1a74c02c642b4fb5e5fb5611">sdf_graph_query</a> (sdf_graph_ptr g)</td></tr>
<tr class="separator:a6e863c7b1a74c02c642b4fb5e5fb5611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd85195bc697ae371cb9d571b5aa01c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a1bd85195bc697ae371cb9d571b5aa01c">to_string</a> (<a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> const &amp;info)</td></tr>
<tr class="separator:a1bd85195bc697ae371cb9d571b5aa01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ad6734ca9b6962775bcee5521bc376e84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::sdf_graph_query_info::was_launched </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates if graph has been launched and started execution.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the graph has already been launched and has started execution.<br/>
 FALSE otherwise. </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00499">499</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a3e5418d595ffa8584adff4c786224452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::sdf_graph_query_info::has_completed </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates if the graph has completed execution or been cancelled.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the graph has completed execution or been cancelled.<br/>
 FALSE otherwise. </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00508">508</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<a class="anchor" id="aec655fd2b14fd17d83dbd67c43fb024b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::sdf_graph_query_info::is_paused </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates if the graph was launched and has been paused.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the graph was launched and has been paused.<br/>
 FALSE otherwise. </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00517">517</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a7696c6b537cd850c9a3a6763561504db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::sdf_graph_query_info::current_min_iteration </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides the minimum graph iteration started by all graph nodes.</p>
<ul>
<li>Defined iff <code><a class="el" href="group__sdf__doc.html#a3e5418d595ffa8584adff4c786224452">has_completed()</a> == true</code> or <code><a class="el" href="group__sdf__doc.html#aec655fd2b14fd17d83dbd67c43fb024b">is_paused()</a> == true</code>.</li>
<li>On <code>iter_non_synced</code> exit or pause, <a class="el" href="group__sdf__doc.html#a7696c6b537cd850c9a3a6763561504db">current_min_iteration()</a> and <a class="el" href="group__sdf__doc.html#a21bcc3455c9805e71a7244231191b049">current_max_iteration()</a> together bound the range of iterations completed by all graph nodes.</li>
<li>On <code>iter_synced</code> exit or pause, both are equal. In contrast, both being equal does not imply <code>iter_synced</code>, since some nodes may have been interrupted in the middle of executing a node iteration.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The minimum graph iteration that every node in the graph has started or exceeded.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#a21bcc3455c9805e71a7244231191b049">current_max_iteration()</a> </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00538">538</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a21bcc3455c9805e71a7244231191b049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::sdf_graph_query_info::current_max_iteration </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides the maximum graph iteration completed by any graph node.</p>
<ul>
<li>Defined iff <code><a class="el" href="group__sdf__doc.html#a3e5418d595ffa8584adff4c786224452">has_completed()</a> == true</code> or <code><a class="el" href="group__sdf__doc.html#aec655fd2b14fd17d83dbd67c43fb024b">is_paused()</a> == true</code>.</li>
<li>On <code>iter_non_synced</code> exit or pause, <a class="el" href="group__sdf__doc.html#a7696c6b537cd850c9a3a6763561504db">current_min_iteration()</a> and <a class="el" href="group__sdf__doc.html#a21bcc3455c9805e71a7244231191b049">current_max_iteration()</a> together bound the range of iterations completed by all graph nodes.</li>
<li>On <code>iter_synced</code> exit or pause, both are equal. In contrast, both being equal does not imply <code>iter_synced</code>, since some nodes may have been interrupted in the middle of executing a node iteration.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The maximum graph iteration that a node anywhere in the graph has completed.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#a7696c6b537cd850c9a3a6763561504db">current_min_iteration()</a> </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00564">564</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a273d6319b4fbb0947bcc2a6a9ff863e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdf__doc.html#ga94c0b95e227ce2a63f0df4f6b6dbb44a">sdf_interrupt_type</a> mare::sdf_graph_query_info::intr_type </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interruption type observed after the last cancel or pause request (if any) to take effect.</p>
<dl class="section return"><dt>Returns</dt><dd>The interruption type in effect when the query was made.<br/>
 <code>undef</code>, if the graph was not paused, cancelled or completed when the query was made.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>sdf_interrupt_type </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00582">582</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<h4 class="groupheader">Related Function Documentation</h4>
<a class="anchor" id="a6e863c7b1a74c02c642b4fb5e5fb5611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> sdf_graph_query </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries the state of an SDF graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to graph to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query information that samples the current execution state of the graph.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> for a description of the graph query information. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bd85195bc697ae371cb9d571b5aa01c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> const &amp;&#160;</td>
          <td class="paramname"><em>info</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the graph query information to a string suitable for printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The graph query information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query information formatted into a string suitable for printing. </dd></dl>

</div>
</div>

</div>
</div>
<a name="classmare_1_1node__channels" id="classmare_1_1node__channels"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class mare::node_channels</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Introspection data-structure used by the programmatic body of an SDF node.</p>
<p>In addition to using <code>body(T1&amp; t1, T2&amp; t2, ..., Tn&amp; tn)</code>, where the type signature is fixed at compile-time and a priori fixes the data-types, direction and number of channels connecting to that body's SDF node, MARE SDF allows a programmatic introspection body with the following type signature that can discover the nature of channels connected to it:<br/>
 <code>body(node_channels&amp; ncs)</code></p>
<p>Inside the body, the user-code can use the <code>ncs</code> object to query the number of channels connected, and for each channel query its direction (in or out) and the element-size carried by it. While <a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">node_channels</a> provides the user the flexibility to attach however many channels of whatever user-data-types to a node, type-safety is reduced as there is no longer compile-time type matching between the type signature of <code>body</code> and the types and number of channels attached to the node.</p>
<p><a class="el" href="group__sdf__doc.html#a40da95d2c426d16bef90c86a1b307aa3">read()</a> and <a class="el" href="group__sdf__doc.html#a35c857a6b03b5813eebfeed6cd742b04">write()</a> methods inside <a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">node_channels</a> allow the user-code to access data popped from in-channels and provide data to push to out-channels. The user-code must pass program variables by reference, whose sizes must match the element-sizes of the corresponding channels. <a class="el" href="group__sdf__doc.html#a40da95d2c426d16bef90c86a1b307aa3">read()</a> and <a class="el" href="group__sdf__doc.html#a35c857a6b03b5813eebfeed6cd742b04">write()</a> provide some runtime safety by checking that the size of the passed program variable matches the element-size of the channel.</p>
<p>Runtime error if a write is attempted on an in-channel or if a read is attempted on an out-channel. </p>

<p>Definition at line <a class="el" href="sdfpr_8hh_source.html#l00048">48</a> of file <a class="el" href="sdfpr_8hh_source.html">sdfpr.hh</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public member functions</h3></td></tr>
<tr class="memitem:a7f709fb9506c1fd4e0f51037fb4312ab"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a7f709fb9506c1fd4e0f51037fb4312ab">get_num_channels</a> () const </td></tr>
<tr class="separator:a7f709fb9506c1fd4e0f51037fb4312ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ef048fba6f152736b774e63dec98c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a76ef048fba6f152736b774e63dec98c7">is_in_channel</a> (std::size_t channel_index) const </td></tr>
<tr class="separator:a76ef048fba6f152736b774e63dec98c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a4ab2c981a0f90d9733c8e2dd67ea0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a07a4ab2c981a0f90d9733c8e2dd67ea0">is_out_channel</a> (std::size_t channel_index) const </td></tr>
<tr class="separator:a07a4ab2c981a0f90d9733c8e2dd67ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853694101631d77e78b7473d9b7dece"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a0853694101631d77e78b7473d9b7dece">get_elemsize</a> (std::size_t channel_index) const </td></tr>
<tr class="separator:a0853694101631d77e78b7473d9b7dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40da95d2c426d16bef90c86a1b307aa3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40da95d2c426d16bef90c86a1b307aa3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a40da95d2c426d16bef90c86a1b307aa3">read</a> (T &amp;t, std::size_t channel_index)</td></tr>
<tr class="separator:a40da95d2c426d16bef90c86a1b307aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c857a6b03b5813eebfeed6cd742b04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35c857a6b03b5813eebfeed6cd742b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sdf__doc.html#a35c857a6b03b5813eebfeed6cd742b04">write</a> (T const &amp;t, std::size_t channel_index)</td></tr>
<tr class="separator:a35c857a6b03b5813eebfeed6cd742b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:afe3be613d63b06dbf7099d932c2c1b44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3be613d63b06dbf7099d932c2c1b44"></a>
std::vector&lt; internal::direction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_vdir</b></td></tr>
<tr class="separator:afe3be613d63b06dbf7099d932c2c1b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9531a26c1e7fc593c2a75d3928cfd780"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9531a26c1e7fc593c2a75d3928cfd780"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_velemsize</b></td></tr>
<tr class="separator:a9531a26c1e7fc593c2a75d3928cfd780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5479b11f0f9854e02d3118c0ecdee79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5479b11f0f9854e02d3118c0ecdee79"></a>
std::vector&lt; char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_vbuffer</b></td></tr>
<tr class="separator:af5479b11f0f9854e02d3118c0ecdee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr class="memitem:a31be5e72a5402fe57faae4dde873d0e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31be5e72a5402fe57faae4dde873d0e3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>internal::node_channels_accessor</b></td></tr>
<tr class="separator:a31be5e72a5402fe57faae4dde873d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a7f709fb9506c1fd4e0f51037fb4312ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::node_channels::get_num_channels </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of channels connected to the node. Channels are accessed by their indices: 0 to <a class="el" href="group__sdf__doc.html#a7f709fb9506c1fd4e0f51037fb4312ab">get_num_channels()</a>-1</p>
<dl class="section return"><dt>Returns</dt><dd>Number of channels connected the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a76ef048fba6f152736b774e63dec98c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::node_channels::is_in_channel </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channel_index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the specified channel is an in-channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_index</td><td>Index to a connected channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if in-channel to the node. FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a07a4ab2c981a0f90d9733c8e2dd67ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::node_channels::is_out_channel </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channel_index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the specified channel is an out-channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_index</td><td>Index to a connected channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if out-channel to the node. FALSE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0853694101631d77e78b7473d9b7dece"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::node_channels::get_elemsize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channel_index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves element-size carried by the specified channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_index</td><td>Index to a connected channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element-size carried by the specified channel. </dd></dl>

</div>
</div>
<a class="anchor" id="a40da95d2c426d16bef90c86a1b307aa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::node_channels::read </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a popped value from the specified channel into a program variable of data-type <code>T</code>.</p>
<p>Multiple reads on a channel are allowed, each returning the same popped value (since the channel pop occurred prior to the invocation of the node's body).</p>
<p>Runtime error if <code>sizeof(T) != get_elemsize(channel_index)</code>.<br/>
 Runtime error if <code>!is_in_channel(channel_index)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Reference to a program variable to which the popped value will be copied.</td></tr>
    <tr><td class="paramname">channel_index</td><td>Index to a connected channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35c857a6b03b5813eebfeed6cd742b04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::node_channels::write </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>channel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the value of a program variable of data-type <code>T</code>. The saved value will subsequently be pushed to the specified channel.</p>
<p>Multiple writes on a channel are allowed, with only the final write providing the value pushed (channel push will occur after completion of the node's body).</p>
<p>Runtime error if <code>sizeof(T) != get_elemsize(channel_index)</code>.<br/>
 Runtime error if <code>!is_out_channel(channel_index)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Reference to a program variable whose value will be saved for pushing to the channel.</td></tr>
    <tr><td class="paramname">channel_index</td><td>Index to a connected channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga25383b6ec53acd5ad739f159cd85863f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;internal::direction, channel*&gt; <a class="el" href="group__sdf__doc.html#ga25383b6ec53acd5ad739f159cd85863f">mare::tuple_dir_channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A tuple holding a channel's binding to an in or out direction.</p>
<p>Tuple is not templated on the user-data-type of the channel data. Suitable for programmatic construction of graph.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#gaf0276f6027b29e74dfa7826864792bf7">as_in_channel_tuple()</a> and <a class="el" href="group__sdf__doc.html#gaf11ee6c728ca9ebc43e620cbecdd5485">as_out_channel_tuple()</a> produce bindings of type tuple_dir_channel. </dd></dl>

<p>Definition at line <a class="el" href="sdfpr_8hh_source.html#l00153">153</a> of file <a class="el" href="sdfpr_8hh_source.html">sdfpr.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga94c0b95e227ce2a63f0df4f6b6dbb44a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sdf__doc.html#ga94c0b95e227ce2a63f0df4f6b6dbb44a">mare::sdf_interrupt_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Types of graph interruption. Used both for qualifying interruption requests and for characterizing the outcome of an interruption.</p>
<ul>
<li><code>undef</code>:<ul>
<li>Interruption type is not set</li>
</ul>
</li>
<li><code>iter_non_synced</code>:<ul>
<li>At interruption, all nodes in the graph need not have executed the same number of graph iterations.</li>
</ul>
</li>
<li><code>iter_synced</code>:<ul>
<li>At interruption, all nodes in the graph must have completed exactly the same number of graph iterations.</li>
</ul>
</li>
</ul>
<p>Note that <code>iter_synced</code> is a special case of <code>iter_non_synced</code>. It is possible for a <a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a> or <a class="el" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">cancel()</a> to request interruption with <code>iter_non_synced</code> semantics, and the graph to interrupt with <code>iter_synced</code> semantics.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a> and <a class="el" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">cancel()</a> make use of sdf_interrupt_type to specify the interruption semantics when requesting an interruption of the graph execution.</dd>
<dd>
<a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> where a sdf_interrupt_type field provides status information on the graph execution state after an interruption or completion of the graph. </dd></dl>

<p>Definition at line <a class="el" href="sdf_8hh_source.html#l00299">299</a> of file <a class="el" href="sdf_8hh_source.html">sdf.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga87ae4b477aa7816a538450bae55ed297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Trange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::preload_channel </td>
          <td>(</td>
          <td class="paramtype">data_channel&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Trange const &amp;&#160;</td>
          <td class="paramname"><em>tr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds delay initializer elements to a channel.</p>
<p>Edges in a synchronous dataflow graph can have delays associated with them. Any cycle in the graph must have at least one delay on at least one of the edges constituting the cycle in order to be a valid synchronous dataflow graph. In general, additional delays in a cycle or delays on purely feed-forward paths alter the semantics of the graph.</p>
<p>With MARE SDF, edges are implemented as channels. A delay of 'N' is associated with a channel by adding N initializer elements to the channel using <a class="el" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>A <code>data_channel&lt;T&gt;</code> of user-defined-type <code>T</code>.</td></tr>
    <tr><td class="paramname">tr</td><td>A container of N elements of data-type <code>T</code>, where N is the desired number of delays to add to the channel. N must be &gt; 0. The container can be any data-structure supporting range-based iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d04a6f4b558cbc80fe9cd54aa5e6dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdf_graph_ptr mare::create_sdf_graph </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an empty graph.</p>
<p>Nodes must subsequently be created with <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a> calls prior to launching graph.</p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the created graph. </dd></dl>

</div>
</div>
<a class="anchor" id="ga575be6357d0a6eff6570efa0b0ba2cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::destroy_sdf_graph </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr &amp;&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a graph.</p>
<p>Invoke on graph g that has either not been launched, has completed execution, or has been cancelled. Undefined behavior if an executing graph is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the graph to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2edf34ad1ff554c95ca3f25e74e42382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">io_channels&lt;Ts...&gt; mare::with_inputs </td>
          <td>(</td>
          <td class="paramtype">data_channel&lt; Ts &gt; &amp;...&#160;</td>
          <td class="paramname"><em>dcs</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a list of data-channels will be inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcs</td><td>A variadic list of data-channels <code>data_channel&lt;T1&gt;</code> to <code>data_channels&lt;Tn&gt;</code> of user-defined-types <code>T1</code> to <code>Tn</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object binding the data-channels to the input direction. Pass to <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a> to indicate that the created node will treat these channels as input.</dd></dl>
<p>Due to some limitations in Visual Studio 2013 support for C++11, only upto 4 channels are supported in each <a class="el" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs()</a> call when compiling with VS 2013 (no limitation when compiling with gcc or clang). </p>

</div>
</div>
<a class="anchor" id="gaaa206ac31609f470885c041d223bb179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">io_channels&lt;Ts...&gt; mare::with_outputs </td>
          <td>(</td>
          <td class="paramtype">data_channel&lt; Ts &gt; &amp;...&#160;</td>
          <td class="paramname"><em>dcs</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a list of data-channels will be outputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcs</td><td>A variadic list of data-channels <code>data_channel&lt;T1&gt;</code> to <code>data_channels&lt;Tn&gt;</code> of user-defined-types <code>T1</code> to <code>Tn</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object binding the data-channels to the output direction. Pass to <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a> to indicate that the created node will treat these channels as output.</dd></dl>
<p>Due to some limitations in Visual Studio 2013 support for C++11, only upto 4 channels are supported in each <a class="el" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs()</a> call when compiling with VS 2013 (no limitation when compiling with gcc or clang). </p>

</div>
</div>
<a class="anchor" id="gadba8cd1885e057f08a82c0cc6f5f8f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Body , typename... IOC_GROUPS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;internal::is_MDCAW&lt;IOC_GROUPS...&gt;::value, sdf_node_ptr&gt;::type mare::create_sdf_node </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Body &amp;&amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IOC_GROUPS const &amp;...&#160;</td>
          <td class="paramname"><em>io_channels_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new node within the specified SDF graph.</p>
<p>The node needs a user-defined <code>body</code> and a sequence of input/output data-channels to connect to.</p>
<p>The <code>body</code> is a function or a callable object supporting invocation as follows: </p>
<dl class="section user"><dt></dt><dd><code>body(T1&amp; t1, T2&amp; t2, T3&amp; t3, ..., Tn&amp; tn)</code></dd></dl>
<p>where <code>T1</code> to <code>Tn</code> are the user-data-types of <code>data_channel&lt;T1&gt;</code> to <code>data_channel&lt;T2&gt;</code> connected to the node in the same order.</p>
<p>Data-channels are connected as inputs or outputs to the node when passed as parameters wrapped in <code><a class="el" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs()</a></code> or <code><a class="el" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs()</a></code>, respectively, to the <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a> call.</p>
<p>During the execution of the graph, the SDF runtime will invoke <code>body</code> with an argument list of references to elements of types <code>T1</code> to <code>Tn</code>, corresponding to a single element from each of the connected channels. All input channels would have been popped by the SDF runtime so <code>body</code> can read a value for each of those channels. <code>body</code> must subsequently write a value to the elements corresponding to the output channels, which the SDF runtime will subsequently push on those channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the graph in which this node is to be created.</td></tr>
    <tr><td class="paramname">body</td><td>A function or callable object that accepts references to an element of each of the connected channels. <code>body</code> can also be a programmatic introspection function.</td></tr>
    <tr><td class="paramname">io_channels_groups</td><td>A sequence of channels, in groups of <code>io_channels</code> created <a class="el" href="group__sdf__doc.html#ga2edf34ad1ff554c95ca3f25e74e42382">with_inputs()</a> and/or <a class="el" href="group__sdf__doc.html#gaaa206ac31609f470885c041d223bb179">with_outputs()</a>. The ordering of the channels must correspond to the types of the parameters accepted by <code>body</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the created node.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">node_channels</a> for programmatic introspection body</dd></dl>
<p>Due to some limitations in Visual Studio 2013 support for C++11, only upto 5 <code>io_channels_groups</code> are allowed when compiling with VS 2013 (no limitation when compiling with gcc or clang). </p>

</div>
</div>
<a class="anchor" id="gafb99ad11bf97101d95e5f794cad60881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::assign_cost </td>
          <td>(</td>
          <td class="paramtype">sdf_node_ptr&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>execution_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns an execution cost to the node (cost defaults to 1.0, if unspecified).</p>
<p>The current execution model of SDF needs node costs as estimates of the relative execution times of nodes, in order to perform load balancing. The next SDF release will perform load balancing without the use of <a class="el" href="group__sdf__doc.html#gafb99ad11bf97101d95e5f794cad60881">assign_cost()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Handle to an SDF node.</td></tr>
    <tr><td class="paramname">execution_cost</td><td>The execution cost to assign to the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41492c16474885aaf1689d8d1976abd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdf_graph_ptr mare::get_graph_ptr </td>
          <td>(</td>
          <td class="paramtype">sdf_node_ptr&#160;</td>
          <td class="paramname"><em>node</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the graph that contains the specified node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Handle to an SDF node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the graph that contains the node. </dd></dl>

</div>
</div>
<a class="anchor" id="gac9e3b36c636e8afd1ba7788a49a37592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t mare::get_debug_id </td>
          <td>(</td>
          <td class="paramtype">sdf_node_ptr&#160;</td>
          <td class="paramname"><em>node</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the unique integer ID automatically assigned to the node within its graph.</p>
<p>At node creation (via <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a>), an integer ID is automatically generated and assigned to the node. The value of the ID starts from 0 for the first node created in the graph and increments for each subsequent node created in the same graph. The ID is provided only as a convenience for the user-code: to aid debugging, identify creation order and identify uniquely. The ID is fixed once the node is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Handle to an SDF node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer ID assigned to the node. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf9359313b799b03561c860d41b1ba7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::launch_and_wait </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launches execution of an SDF graph for an unbounded number of graph iterations, and blocks until the graph is cancelled.</p>
<p>Runtime error if graph g was previously launched. Runtime error if graph g is structurally incomplete, i.e., there are channels unconnected on one end. Runtime error if graph g is not schedulable due to 0-delay cycles: a cycle must have at least one channel with at least one preloaded value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to launch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#ga87ae4b477aa7816a538450bae55ed297">preload_channel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7abec4f4cc3e3a5ab503ccbf230c9914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::launch_and_wait </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Launches execution of an SDF graph for a specified number of graph iterations, and blocks until the graph completes or is cancelled.</p>
<p>All nodes run for exactly num_iterations, unless cancelled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to launch.</td></tr>
    <tr><td class="paramname">num_iterations</td><td>Number of graph iterations to run g.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>launch_and_wait(sdf_graph_ptr g) for the possible runtime errors on g. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6d88ec9965da7eaa9da60ab7c27041b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::launch </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous launch of an SDF graph for an unbounded number of graph iterations. Does not block for the graph to launch or complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to launch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>launch_and_wait(sdf_graph_ptr g) for the possible runtime errors on g. </dd>
<dd>
<a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a> to block on an asynchronously launched graph. </dd></dl>

</div>
</div>
<a class="anchor" id="ga482b1499e18d1207b414eac4de554a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::launch </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_iterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous launch of an SDF graph for a specified number of graph iterations. Does not block for the graph to launch or complete.</p>
<p>All nodes run for exactly num_iterations, unless cancelled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to launch.</td></tr>
    <tr><td class="paramname">num_iterations</td><td>Number of graph iterations to run g.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>launch_and_wait(sdf_graph_ptr g) for the possible runtime errors on g. </dd>
<dd>
<a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a> to block on an asynchronously launched graph. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85399a8348917a0a0bb47d40bc5fd069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::wait_for </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks on an asynchronously launched graph to complete execution or be cancelled.</p>
<p>Multiple <a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a> calls are allowed to block on same graph. A <a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a> invoked after the graph has already completed or been cancelled will return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to block on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2d8af997cd2133796de15818de3c506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::cancel </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdf_interrupt_type&#160;</td>
          <td class="paramname"><em>intr_type</em> = <code>sdf_interrupt_type::iter_non_synced</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels the execution of a graph ASAP.</p>
<p>A graph can be cancelled</p>
<ul>
<li>before it launches (on launch, graph will terminate without execution)</li>
<li>while it is executing</li>
<li>or, after it has already finished execution (no effect)</li>
</ul>
<p><a class="el" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">cancel()</a> returns immediately, while any <a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a> will block until the cancel takes effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to SDF graph to cancel.</td></tr>
    <tr><td class="paramname">intr_type</td><td>Interruption type requested.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>intr_type == iter_non_synced</code>:<ul>
<li>Non-iteration-synchronized cancel, no guarantee that all nodes will stop on the same graph iteration. But executing nodes are not interrupted.</li>
</ul>
</li>
<li><code>intr_type == iter_synced</code>:<ul>
<li>Iteration-synchronized cancel, all graph nodes complete the exact same number of graph iterations.</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd>sdf_interrupt_type</dd></dl>
<p>Okay to cancel either from program external to graph g or from within a node of g.</p>
<dl class="section user"><dt>Interruption Request Queue</dt><dd>Each graph has its own interruption-request queue. <a class="el" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">cancel()</a> enqueues an interruption request for the SDF runtime to process. Multiple incoming requests get enqueued and are processed in order by the graph's runtime. Similarly, <a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a> also enqueues an interruption requests into the same interruotion queue. When a cancel request earlier in the queue takes effect, it renders the remaining requests to have no effect (all pauses will unblock, resumes will have no effect).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for()</a>, <a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a>, <a class="el" href="group__sdf__doc.html#ga4bb43e41f6c48947337241f6e3f9ecc7">resume()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9022fc00d748993ffd3f6a951b1a493b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::cancel </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>desired_cancel_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdf_interrupt_type&#160;</td>
          <td class="paramname"><em>intr_type</em> = <code>sdf_interrupt_type::iter_non_synced</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels the execution of a graph after all nodes have reached or exceeded a specified number of graph iterations.</p>
<p>Will *attempt* to cancel exactly when all nodes have completed exactly <code>desired_cancel_iteration</code> iteration. If the interruption queue already has a prior request that is not processed as yet, then it is guaranteed* that the cancel will happen precisely when all nodes complete <code>desired_cancel_iteration</code> (i.e., <code>iter_synced</code> semantics), regardless of the <code>intr_type</code> in the cancel request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to cancel.</td></tr>
    <tr><td class="paramname">desired_cancel_iteration</td><td>Graph iteration that all nodes must complete before cancel.</td></tr>
    <tr><td class="paramname">intr_type</td><td>Interruption type requested.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>intr_type == iter_non_synced</code>:<ul>
<li>some nodes may execute additional iterations, though every node will execute till <code>desired_cancel_iteration</code> iteration.</li>
</ul>
</li>
<li><code>intr_type == iter_synced</code>:<ul>
<li>all nodes will complete the exact same number of iterations, possibly past the <code>desired_cancel_iteration</code> iteration.</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#gae8679478ca1506a6c96b5953b3b64a20">sdf_graph_query()</a> determines on which graph iteration the cancel took effect and with what interrution semantics. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e722f0ab6dd94c7352bd26e7652c4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::pause </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdf_interrupt_type&#160;</td>
          <td class="paramname"><em>intr_type</em> = <code>sdf_interrupt_type::iter_non_synced</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the execution of a graph ASAP.</p>
<p>A graph can be paused</p>
<ul>
<li>before it launches (on launch, graph will pause before executing)</li>
<li>while it is executing</li>
<li>or, after it has already finished execution (no effect)</li>
</ul>
<p><a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a> blocks until the graph has either paused execution in response to this particular pause request (not any other pause request), or has terminated for other reasons (such as a preceding cancel request in the graph's interruption queue).</p>
<p><a class="el" href="group__sdf__doc.html#ga4bb43e41f6c48947337241f6e3f9ecc7">resume()</a> invoked after a <a class="el" href="group__sdf__doc.html#ga7e722f0ab6dd94c7352bd26e7652c4b4">pause()</a> causes the graph to resume execution precisely from where it paused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to SDF graph to pause.</td></tr>
    <tr><td class="paramname">intr_type</td><td>Interruption type requested.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>intr_type == iter_non_synced</code>:<ul>
<li>Non-iteration-synchronized pause, no guarantee that all nodes will pause on the same graph iteration. But executing nodes are not interrupted.</li>
</ul>
</li>
<li><code>intr_type == iter_synced</code>:<ul>
<li>Iteration-synchronized pause, all graph nodes complete the exact same number of graph iterations.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this pause took effect<br/>
 FALSE if graph got terminated or had already completed.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>sdf_interrupt_type</dd>
<dd>
cancel(sdf_graph_ptr g, sdf_interrupt_type intr_type) for details on the interruption request queue.</dd></dl>
<p>Okay to pause either from program external to graph g or from within a node of g.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#ga4bb43e41f6c48947337241f6e3f9ecc7">resume()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5508552d0d90d864f48e8ec418b44a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mare::pause </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>desired_pause_iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdf_interrupt_type&#160;</td>
          <td class="paramname"><em>intr_type</em> = <code>sdf_interrupt_type::iter_non_synced</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the execution of a graph after all nodes have reached or exceeded a specified number of graph iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to pause.</td></tr>
    <tr><td class="paramname">desired_pause_iteration</td><td>Graph iteration that all nodes must complete before cancel.</td></tr>
    <tr><td class="paramname">intr_type</td><td>Interruption type requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this pause took effect<br/>
 FALSE if graph got terminated or had already completed.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pause(sdf_graph_ptr g, sdf_interrupt_type intr_type) for details on pause blocking semantics, interruption semantics and resume semantics. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bb43e41f6c48947337241f6e3f9ecc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mare::resume </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes execution after the graph has been paused.</p>
<p>Non-blocking. Runtime error if the graph was not paused when <a class="el" href="group__sdf__doc.html#ga4bb43e41f6c48947337241f6e3f9ecc7">resume()</a> is called. No effect if the graph is already completed or cancelled. Can be called from any thread or task, not necessarily from where pause was executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph to pause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>pause(sdf_graph_ptr g, sdf_interrupt_type intr_type); </dd>
<dd>
pause( sdf_graph_ptr g, std::size_t desired_pause_iteration, sdf_interrupt_type intr_type) </dd></dl>

</div>
</div>
<a class="anchor" id="gae8679478ca1506a6c96b5953b3b64a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdf_graph_query_info mare::sdf_graph_query </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the state of an SDF graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to graph to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query information that samples the current execution state of the graph.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1sdf__graph__query__info">sdf_graph_query_info</a> for a description of the graph query information. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef753b805cc7e71c8926d9c730e80657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mare::to_string </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_query_info const &amp;&#160;</td>
          <td class="paramname"><em>info</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the graph query information to a string suitable for printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The graph query information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query information formatted into a string suitable for printing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56a79ddb2b738544bd3e09bef58dcaf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OStream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OStream&amp; mare::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">OStream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdf_graph_query_info const &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insertion operator to output formatted graph query information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">info</td><td>The graph query information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0276f6027b29e74dfa7826864792bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tuple_dir_channel mare::as_in_channel_tuple </td>
          <td>(</td>
          <td class="paramtype">data_channel&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dc</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds a channel as in-channel for connecting to a node.</p>
<p>Used for connecting the channel to a programmatically connected node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>A data-channel templated on a user-data-type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A template-free binding of the channel as in-channel, suitable for passing around to generic parts of the application that are not specific to the user-data-type used for channel construction. </dd></dl>

<p>Definition at line <a class="el" href="sdfpr_8hh_source.html#l00168">168</a> of file <a class="el" href="sdfpr_8hh_source.html">sdfpr.hh</a>.</p>

</div>
</div>
<a class="anchor" id="gaf11ee6c728ca9ebc43e620cbecdd5485"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tuple_dir_channel mare::as_out_channel_tuple </td>
          <td>(</td>
          <td class="paramtype">data_channel&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dc</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds a channel as out-channel for connecting to a node.</p>
<p>Used for connecting the channel to a programmatically connected node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dc</td><td>A data-channel templated on a user-data-type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A template-free binding of the channel as out-channel, suitable for passing around to generic parts of the application that are not specific to the user-data-type used for channel construction. </dd></dl>

<p>Definition at line <a class="el" href="sdfpr_8hh_source.html#l00187">187</a> of file <a class="el" href="sdfpr_8hh_source.html">sdfpr.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ed796590ccbf20e02c99a4ca6af9fdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sdf_node_ptr mare::create_sdf_node </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(node_channels &amp;)&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; tuple_dir_channel &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_dir_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Programmatic connection of a node to channels, using a body with programmatic introspection.</p>
<p>The signature of <code>body</code> does not carry template information on the user-data-types of the connected channels, the number of connected channels or their directions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph in which the node is to created.</td></tr>
    <tr><td class="paramname">body</td><td>An introspection function on <a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">node_channels</a>.</td></tr>
    <tr><td class="paramname">v_dir_channels</td><td>Captures the channels connected to the node along with their directions. Expressed as a vector of channel-direction bindings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the created node.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#classmare_1_1node__channels">node_channels</a> on how <code>body</code> can introspect on the channels connected to it.</dd>
<dd>
<a class="el" href="group__sdf__doc.html#gaf0276f6027b29e74dfa7826864792bf7">as_in_channel_tuple()</a> for creation of an in-channel binding.</dd>
<dd>
<a class="el" href="group__sdf__doc.html#gaf11ee6c728ca9ebc43e620cbecdd5485">as_out_channel_tuple()</a> for creation of an out-channel binding. </dd></dl>

</div>
</div>
<a class="anchor" id="ga873b621dfc5a63fd354cef670e7464b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Body &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sdf_node_ptr mare::create_sdf_node </td>
          <td>(</td>
          <td class="paramtype">sdf_graph_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Body &amp;&amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; tuple_dir_channel &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_dir_channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Programmatic connection of a node to channels, using a body with type-signature listing the user-data-types of connected channels.</p>
<p><code>body</code> is a callable (e.g., a function, object with operator(), a lambda with capture) whose callable type-signature lists the user-data-types of the connected channels. <code>body</code> is callable with a type signature like the following:<br/>
 <code>body(T1&amp; t1, T2&amp; t2, ..., Tn&amp; tn)</code></p>
<p>where <code>T1</code> to <code>Tn</code> are the user-data-types of the channels connected to the node, though not visible to the compiler in the channel descriptions in <code>v_dir_channels</code>.</p>
<p>The channels are expressed without user-data-type information. This form of <a class="el" href="group__sdf__doc.html#gadba8cd1885e057f08a82c0cc6f5f8f5a">create_sdf_node()</a> is useful when the channels may have been passed through generic parts of the application code that was not specialized to the user-data-types used in channel creation, but node creation occurs within specialized code aware of the channel user-data-types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Handle to the SDF graph in which the node is to created.</td></tr>
    <tr><td class="paramname">body</td><td>A callable with type-signature explicitly listing the user-data-types of the connected channels.</td></tr>
    <tr><td class="paramname">v_dir_channels</td><td>Captures the channels connected to the node along with their directions. Expressed as a vector of channel-direction bindings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the created node.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__sdf__doc.html#gaf0276f6027b29e74dfa7826864792bf7">as_in_channel_tuple()</a> for creation of an in-channel binding.</dd>
<dd>
<a class="el" href="group__sdf__doc.html#gaf11ee6c728ca9ebc43e620cbecdd5485">as_out_channel_tuple()</a> for creation of an out-channel binding. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2012-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 footer.html - footer file used to customize the footers on each HTML page for the API 
               Interface Specification documents.
 Updated:  11/05/13 LB Removed confidential, distribution, and export statement.
 Updated:  09/20/13 LB Updated to support mare project's User Guide and API doc.
 Updated:  04/18/13 LB Added Documentation and Interface Specification in place of hard-coding doc dcn. Deleted original
                       use of Documentation and Interface Specification to display text in the left portion of the footer.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1
 Updated:  01/18/13 LB Replaced qualcomm_logo.gif to QTI_Logo.png
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support the Rev E Alpha Doxygen-to-HTML-PDF process. -->
<!-- start footer part -->
<!-- 7/12/12 JG added div class defined in css to include warning statement on all pages -->
<!--[if lte IE 8]><div class="warningmsgie8"><![endif]-->
<!--[if(gte IE 9)|!(IE)]><!--><div class="warningmsg"><!--<![endif]-->
</div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
		<p align="right">HT80-NG608-1 E<br />
        <img class="footer"  alt="QTI Logo" src="qti_logo_HTML.png" />
		</p>
		</li>
  </ul>
</div>
</body>
</html>
