<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2010-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 header.html - Header file used to customize the headers on each HTML page for the API 
               Interface Specification documents.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1.
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support Rev E Alpha process using Doxygen 1.8.2 -->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Multicore Asynchronous Runtime Environment Patterns</title><!--END !PROJECT_NAME-->
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multicore Asynchronous Runtime Environment
   &#160;<span id="projectnumber">HT80-NG608-1 E</span>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-QCOM -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="revision_history.html"><span>Revision&#160;History</span></a></li>
      <li><a href="introduction.html"><span>Introduction</span></a></li>
      <li><a href="usergroup0.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="usergroup1.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup3.html"><span>Tutorials</span></a></li>
      <li><a href="usergroup4.html"><span>Reference&#160;Manual</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__patterns__doc.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Patterns<div class="ingroups"><a class="el" href="group__chapter__patterns__doc.html">Patterns Reference API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Using the patterns defined in this chapter requires including the following header file: </p>
<pre class="fragment">    #include &lt;mare/patterns.hh&gt;</pre> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae7a6eadac0401497f58159958e883bb8"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:gae7a6eadac0401497f58159958e883bb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#gae7a6eadac0401497f58159958e883bb8">mare::pfor_each_async</a> (group_ptr g, InputIterator first, InputIterator last, UnaryFn fn)</td></tr>
<tr class="separator:gae7a6eadac0401497f58159958e883bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d20cd17d7860b96a8c029d57714407"><td class="memTemplParams" colspan="2">template&lt;size_t DIMS, typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga96d20cd17d7860b96a8c029d57714407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga96d20cd17d7860b96a8c029d57714407">mare::pfor_each_async</a> (group_ptr g, const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;r, UnaryFn fn)</td></tr>
<tr class="separator:ga96d20cd17d7860b96a8c029d57714407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84e153297a669ed74acbed259fa8cd6"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:gaf84e153297a669ed74acbed259fa8cd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#gaf84e153297a669ed74acbed259fa8cd6">mare::pfor_each</a> (group_ptr group, InputIterator first, InputIterator last, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:gaf84e153297a669ed74acbed259fa8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd09370ce0af112dd3cb7e65162dbdb"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga9cd09370ce0af112dd3cb7e65162dbdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga9cd09370ce0af112dd3cb7e65162dbdb">mare::pfor_each</a> (InputIterator first, InputIterator last, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:ga9cd09370ce0af112dd3cb7e65162dbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6fc0461681d958b7aa2d61b9d74e8b"><td class="memTemplParams" colspan="2">template&lt;size_t DIMS, typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga4a6fc0461681d958b7aa2d61b9d74e8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga4a6fc0461681d958b7aa2d61b9d74e8b">mare::pfor_each</a> (group_ptr group, const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;r, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:ga4a6fc0461681d958b7aa2d61b9d74e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9cda43766e241597c512009fc85e3c"><td class="memTemplParams" colspan="2">template&lt;size_t DIMS, typename UnaryFn &gt; </td></tr>
<tr class="memitem:gaae9cda43766e241597c512009fc85e3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#gaae9cda43766e241597c512009fc85e3c">mare::pfor_each</a> (const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;r, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:gaae9cda43766e241597c512009fc85e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f111ceddcccf201d501321b7b903f44"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga8f111ceddcccf201d501321b7b903f44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga8f111ceddcccf201d501321b7b903f44">mare::ptransform</a> (group_ptr group, InputIterator first, InputIterator last, OutputIterator d_first, UnaryFn fn)</td></tr>
<tr class="separator:ga8f111ceddcccf201d501321b7b903f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74339f59e081964e9183fecaf25ca965"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga74339f59e081964e9183fecaf25ca965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga74339f59e081964e9183fecaf25ca965">mare::ptransform</a> (InputIterator first, InputIterator last, OutputIterator d_first, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:ga74339f59e081964e9183fecaf25ca965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec36f555de008df5f09ed35422e64de8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryFn &gt; </td></tr>
<tr class="memitem:gaec36f555de008df5f09ed35422e64de8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#gaec36f555de008df5f09ed35422e64de8">mare::ptransform</a> (group_ptr group, InputIterator first1, InputIterator last1, InputIterator first2, OutputIterator d_first, BinaryFn fn)</td></tr>
<tr class="separator:gaec36f555de008df5f09ed35422e64de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70feb8c80bc52adcc998f62e6b0cd846"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryFn &gt; </td></tr>
<tr class="memitem:ga70feb8c80bc52adcc998f62e6b0cd846"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga70feb8c80bc52adcc998f62e6b0cd846">mare::ptransform</a> (InputIterator first1, InputIterator last1, InputIterator first2, OutputIterator d_first, BinaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:ga70feb8c80bc52adcc998f62e6b0cd846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c0d3d2324c02d1ffecbb6d95038979"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:ga82c0d3d2324c02d1ffecbb6d95038979"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga82c0d3d2324c02d1ffecbb6d95038979">mare::ptransform</a> (group_ptr group, InputIterator first, InputIterator last, UnaryFn fn)</td></tr>
<tr class="separator:ga82c0d3d2324c02d1ffecbb6d95038979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c63421790af70e302f1a0117d0ec91"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFn &gt; </td></tr>
<tr class="memitem:gac7c63421790af70e302f1a0117d0ec91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#gac7c63421790af70e302f1a0117d0ec91">mare::ptransform</a> (InputIterator first, InputIterator last, UnaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:gac7c63421790af70e302f1a0117d0ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e21a34b1d45ee24c248d1b8229a983e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryFn &gt; </td></tr>
<tr class="memitem:ga4e21a34b1d45ee24c248d1b8229a983e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga4e21a34b1d45ee24c248d1b8229a983e">mare::pscan_inclusive</a> (group_ptr group, InputIterator first, InputIterator last, BinaryFn fn)</td></tr>
<tr class="separator:ga4e21a34b1d45ee24c248d1b8229a983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c982fbccc7e8dc068d0f74eff988276"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename BinaryFn &gt; </td></tr>
<tr class="memitem:ga0c982fbccc7e8dc068d0f74eff988276"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__patterns__doc.html#ga0c982fbccc7e8dc068d0f74eff988276">mare::pscan_inclusive</a> (InputIterator first, InputIterator last, BinaryFn &amp;&amp;fn)</td></tr>
<tr class="separator:ga0c982fbccc7e8dc068d0f74eff988276"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae7a6eadac0401497f58159958e883bb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each_async </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::for_each</code> (asynchronous).</p>
<p>Applies function object <code>fn</code> in parallel to every iterator in the range [first, last).</p>
 <b>Note:</b> In contrast to <code>std::for_each</code> and <code>ptransform</code>, the iterator is passed to the function, instead of the element.</p>
<p>It is permissible to modify the elements of the range from <code>fn</code>, assuming that <code>InputIterator</code> is a mutable iterator.</p>
 <b>Note:</b> This function does NOT wait for all function applications to finish. Callers must wait on <code>g</code> (see <code>wait_for</code>), if this is desired.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>last-first</code> applications of <code>fn</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) </dd>
<dd>
pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00139">139</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga96d20cd17d7860b96a8c029d57714407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t DIMS, typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each_async </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel version of <code>std::for_each</code> (asynchronous). </p>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(mare::range&lt;DIMS&gt;&amp;, body_with_attrs_gpu&lt; Body, KernelPtr, Kargs...&gt;&amp;&amp;) </dd>
<dd>
pfor_each_async(group_ptr, InputIterator, InputIterator, UnaryFn)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">r</td><td>Range object (1D, 2D or 3D) representing the iteration space. </td></tr>
    <tr><td class="paramname">fn</td><td>the unary function object to be applied </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00184">184</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="gaf84e153297a669ed74acbed259fa8cd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::for_each</code>.</p>
<p>Applies function object <code>fn</code> in parallel to every iterator in the range [first, last).</p>
 <b>Note:</b> In contrast to <code>std::for_each</code> and ptransform, the iterator is passed to the function, instead of the element.</p>
<p>It is permissible to modify the elements of the range from <code>fn</code>, provided that <code>InputIterator</code> is a mutable iterator.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<p>In addition, the call to this function can be canceled by canceling the group passed as argument. However, in the presence of cancelation it is undefined to which extent the iteration space will have been processed.</p>
 <b>Note:</b> The usual rules for cancelation apply, i.e., within <code>fn</code> the cancelation must be acknowledged using <code>abort_on_cancel</code>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>std::distance(first,last)</code> applications of <code>fn</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) <br/>
 </dd>
<dd>
pfor_each_async(group_ptr, InputIterator, InputIterator, UnaryFn) <br/>
 </dd>
<dd>
<a class="el" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">abort_on_cancel()</a></dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">group_ptr g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;g&quot;</span>);</div>
<div class="line">[...]</div>
<div class="line"><span class="comment">// Parallel for-loop using indices</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(g, <span class="keywordtype">size_t</span>(0), vin.size(),</div>
<div class="line">          [=,&amp;vin,&amp;vout] (<span class="keywordtype">size_t</span> i) {</div>
<div class="line">              <span class="keywordflow">while</span> (!finished_lengthy_computation()) {</div>
<div class="line">                 <a class="code" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">abort_on_cancel</a>();</div>
<div class="line">                 process(i);</div>
<div class="line">          });</div>
<div class="line">[...]</div>
<div class="line"><span class="comment">// elsewhere:</span></div>
<div class="line"><a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">cancel</a>(g);</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00463">463</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga9cd09370ce0af112dd3cb7e65162dbdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel version of std::for_each. </p>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;) </dd>
<dd>
ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) </dd>
<dd>
pfor_each_async(group_ptr, InputIterator, InputIterator, UnaryFn)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// Parallel for-loop using indices</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size());</div>
<div class="line"><span class="comment">// vout[i] := 2*vin[i]</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(<span class="keywordtype">size_t</span>(0), vin.size(),</div>
<div class="line">          [=,&amp;vin,&amp;vout] (<span class="keywordtype">size_t</span> i) {</div>
<div class="line">              vout[i] = 2*vin[i];</div>
<div class="line">          });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>start of the range to which to apply 'fn' </td></tr>
    <tr><td class="paramname">last</td><td>end of the range to which to apply 'fn' </td></tr>
    <tr><td class="paramname">fn</td><td>the unary function object to be applied </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00496">496</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a6fc0461681d958b7aa2d61b9d74e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t DIMS, typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel version of <code>std::for_each</code> </p>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(mare::range&lt;DIMS&gt;&amp;, body_with_attrs_gpu&lt; Body, KernelPtr, Kargs...&gt;&amp;&amp;) </dd>
<dd>
pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">r</td><td>Range object (1D, 2D or 3D) representing the iteration space. </td></tr>
    <tr><td class="paramname">fn</td><td>the unary function object to be applied </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00517">517</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="gaae9cda43766e241597c512009fc85e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t DIMS, typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pfor_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ranges__doc.html#classmare_1_1range">mare::range</a>&lt; DIMS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel version of <code>std::for_each</code>. </p>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(mare::range&lt;DIMS&gt;&amp;, body_with_attrs_gpu&lt; Body, KernelPtr, Kargs...&gt;&amp;&amp;) </dd>
<dd>
pfor_each(InputIterator, InputIterator, UnaryFn)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Range object (1D, 2D or 3D) representing the iteration space. </td></tr>
    <tr><td class="paramname">fn</td><td>the unary function object to be applied </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00537">537</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f111ceddcccf201d501321b7b903f44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<p>Applies function object <code>fn</code> in parallel to every dereferenced iterator in the range [first, last) and stores the return value in another range, starting at <code>d_first</code>.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<p>In addition, the call to this function can be canceled by canceling the group passed as argument. However, in the presence of cancelation it is undefined to which extent the iteration space will have been processed.</p>
 <b>Note:</b> The usual rules for cancelation apply, i.e., within <code>fn</code> the cancelation must be acknowledged using <code>abort_on_cancel</code>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>std::distance(first,last)</code> applications of <code>fn</code>.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd>pfor_each</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// arr[i] == 2*vin[N-i]</span></div>
<div class="line"><span class="keywordtype">size_t</span> arr[vin.size()];</div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga8f111ceddcccf201d501321b7b903f44">ptransform</a>(group, begin(vin), end(vin), arr,</div>
<div class="line">           [=] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i) {</div>
<div class="line">             <span class="keywordflow">return</span> 2*i;</div>
<div class="line">           });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">d_first</td><td>Start of the destination range. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00587">587</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga74339f59e081964e9183fecaf25ca965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<dl class="section see"><dt>See Also</dt><dd>ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) </dd>
<dd>
pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// arr[i] == 2*vin[N-i]</span></div>
<div class="line"><span class="keywordtype">size_t</span> arr[vin.size()];</div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga8f111ceddcccf201d501321b7b903f44">ptransform</a>(begin(vin), end(vin), arr,</div>
<div class="line">           [=] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i) {</div>
<div class="line">             <span class="keywordflow">return</span> 2*i;</div>
<div class="line">           });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">d_first</td><td>Start of the destination range. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00643">643</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="gaec36f555de008df5f09ed35422e64de8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename BinaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<p>Applies function object <code>fn</code> in parallel to every pair of dereferenced destination iterators in the range [first1, last1) and [first2,...), and stores the return value in another range, starting at <code>d_first</code>.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<p>In addition, the call to this function can be canceled by canceling the group passed as argument. However, in the presence of cancelation it is undefined to which extent the iteration space will have been processed.</p>
 <b>Note:</b> The usual rules for cancelation apply, i.e., within <code>fn</code> the cancelation must be acknowledged using <code>abort_on_cancel</code>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>std::distance(first1,last1)</code> applications of <code>fn</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// vout[i] == vin[i] + vin[i+1]</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size()-1);</div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga8f111ceddcccf201d501321b7b903f44">ptransform</a>(group,</div>
<div class="line">           begin(vin), begin(vin)+vout.size(),</div>
<div class="line">           begin(vin)+1,</div>
<div class="line">           begin(vout),</div>
<div class="line">           [=] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i, <span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; j) {</div>
<div class="line">             <span class="keywordflow">return</span> i+j;</div>
<div class="line">           });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first1</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last1</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">first2</td><td>Start of the second range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">d_first</td><td>Start of the destination range. </td></tr>
    <tr><td class="paramname">fn</td><td>Binary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00699">699</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga70feb8c80bc52adcc998f62e6b0cd846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename BinaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<p>Applies function object <code>fn</code> in parallel to every pair of dereferenced destination iterators in the range [first1, last1) and [first2,...), and stores the return value in another range, starting at <code>d_first</code>.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>std::distance(first1,last1)</code> applications of <code>fn</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) </dd>
<dd>
pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// vout[i] == vin[i] + vin[i+1]</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size()-1);</div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga8f111ceddcccf201d501321b7b903f44">ptransform</a>(begin(vin), begin(vin)+vout.size(),</div>
<div class="line">           begin(vin)+1,</div>
<div class="line">           begin(vout),</div>
<div class="line">           [=] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i, <span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; j) {</div>
<div class="line">             <span class="keywordflow">return</span> i+j;</div>
<div class="line">           });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last1</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">first2</td><td>Start of the second range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">d_first</td><td>Start of the destination range. </td></tr>
    <tr><td class="paramname">fn</td><td>Binary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00772">772</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga82c0d3d2324c02d1ffecbb6d95038979"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<p>Applies function object <code>fn</code> in parallel to every dereferenced iterator in the range [first, last).</p>
 <b>Note:</b> In contrast to pfor_each, the dereferenced iterator is passed to the function.</p>
<p>It is permissible to modify the elements of the range from <code>fn</code>, assuming that <code>InputIterator</code> is a mutable iterator.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<p>In addition, the call to this function can be canceled by canceling the group passed as argument. However, in the presence of cancelation it is undefined to which extent the iteration space will have been processed.</p>
 <b>Note:</b> The usual rules for cancelation apply, i.e., within <code>fn</code> the cancelation must be acknowledged using <code>abort_on_cancel</code>.</p>
<dl class="section user"><dt>Complexity</dt><dd>Exactly <code>std::distance(first,last)</code> applications of <code>fn</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// Parallel for-loop using indices</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size());</div>
<div class="line"><span class="comment">// vout[i] := 2*vin[i]</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(group,</div>
<div class="line">          <span class="keywordtype">size_t</span>(0), vin.size(),</div>
<div class="line">          [=,&amp;vin,&amp;vout] (<span class="keywordtype">size_t</span> i) {</div>
<div class="line">              vout[i] = 2*vin[i];</div>
<div class="line">          });</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="comment">// Parallel for-loop using iterators</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size());</div>
<div class="line"><span class="comment">// vout[i] := 2*vin[i]</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(group,</div>
<div class="line">          begin(vin), end(vin),</div>
<div class="line">          [&amp;vin,&amp;vout] (vector&lt;size_t&gt;::const_iterator it) {</div>
<div class="line">              vout[it - begin(vin)] = 2 * *it;</div>
<div class="line">          });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00839">839</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="gac7c63421790af70e302f1a0117d0ec91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::ptransform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel version of <code>std::transform</code>.</p>
<dl class="section see"><dt>See Also</dt><dd>ptransform(group_ptr, InputIterator, InputIterator, UnaryFn) </dd>
<dd>
pfor_each(group_ptr, InputIterator, InputIterator, UnaryFn&amp;&amp;)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// Parallel for-loop using indices</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size());</div>
<div class="line"><span class="comment">// vout[i] := 2*vin[i]</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(<span class="keywordtype">size_t</span>(0), vin.size(),</div>
<div class="line">          [=,&amp;vin,&amp;vout] (<span class="keywordtype">size_t</span> i) {</div>
<div class="line">              vout[i] = 2*vin[i];</div>
<div class="line">          });</div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="comment">// Parallel for-loop using iterators</span></div>
<div class="line">vector&lt;size_t&gt; vout(vin.size());</div>
<div class="line"><span class="comment">// vout[i] := 2*vin[i]</span></div>
<div class="line"><a class="code" href="group__gpu__patterns.html#ga5a8a8a086f9cfc7b675357da24cdf420">pfor_each</a>(begin(vin), end(vin),</div>
<div class="line">          [&amp;vin,&amp;vout] (vector&lt;size_t&gt;::const_iterator it) {</div>
<div class="line">              vout[it - begin(vin)] = 2 * *it;</div>
<div class="line">          });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Unary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00877">877</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e21a34b1d45ee24c248d1b8229a983e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename BinaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pscan_inclusive </td>
          <td>(</td>
          <td class="paramtype">group_ptr&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sklansky-style parallel inclusive scan.</p>
<p>Performs an in-place parallel prefix computation using the function object <code>fn</code> for the range [first, last).</p>
<p>It is not permissible for <code>fn</code> to modify the elements of the range. Also, <code>fn</code> should be associative, because the order of applications is not fixed.</p>
 <b>Note:</b> This function returns only after <code>fn</code> has been applied to the whole iteration range.</p>
<p>In addition, the call to this function can be canceled by canceling the group passed as argument. However, in the presence of cancelation it is undefined to which extent the iteration space will have been processed.</p>
 <b>Note:</b> The usual rules for cancelation apply, i.e., within <code>fn</code> the cancelation must be acknowledged using <code>abort_on_cancel</code>.</p>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// After: v&#39; = { v[0], v[0] x v[1], v[0] x v[1] x v[2], ... }</span></div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga4e21a34b1d45ee24c248d1b8229a983e">pscan_inclusive</a>(group,</div>
<div class="line">                begin(v), end(v),</div>
<div class="line">                [] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i, <span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; j) {</div>
<div class="line">                    <span class="keywordflow">return</span> i + j;</div>
<div class="line">                });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>All MARE tasks created are added to this group. </td></tr>
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Binary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00949">949</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c982fbccc7e8dc068d0f74eff988276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename BinaryFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mare::pscan_inclusive </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sklansky-style parallel inclusive scan.</p>
<dl class="section see"><dt>See Also</dt><dd>pscan_inclusive(group_ptr, InputIterator, InputIterator, BinaryFn)</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"><span class="comment">// After: v&#39; = { v[0], v[0] x v[1], v[0] x v[1] x v[2], ... }</span></div>
<div class="line"><a class="code" href="group__patterns__doc.html#ga4e21a34b1d45ee24c248d1b8229a983e">pscan_inclusive</a>(begin(v), end(v),</div>
<div class="line">                [] (<span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; i, <span class="keywordtype">size_t</span> <span class="keyword">const</span>&amp; j) {</div>
<div class="line">                    <span class="keywordflow">return</span> i + j;</div>
<div class="line">                });</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Start of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">last</td><td>End of the range to which to apply <code>fn</code>. </td></tr>
    <tr><td class="paramname">fn</td><td>Binary function object to be applied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="patterns_8hh_source.html#l00979">979</a> of file <a class="el" href="patterns_8hh_source.html">patterns.hh</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2012-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 footer.html - footer file used to customize the footers on each HTML page for the API 
               Interface Specification documents.
 Updated:  11/05/13 LB Removed confidential, distribution, and export statement.
 Updated:  09/20/13 LB Updated to support mare project's User Guide and API doc.
 Updated:  04/18/13 LB Added Documentation and Interface Specification in place of hard-coding doc dcn. Deleted original
                       use of Documentation and Interface Specification to display text in the left portion of the footer.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1
 Updated:  01/18/13 LB Replaced qualcomm_logo.gif to QTI_Logo.png
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support the Rev E Alpha Doxygen-to-HTML-PDF process. -->
<!-- start footer part -->
<!-- 7/12/12 JG added div class defined in css to include warning statement on all pages -->
<!--[if lte IE 8]><div class="warningmsgie8"><![endif]-->
<!--[if(gte IE 9)|!(IE)]><!--><div class="warningmsg"><!--<![endif]-->
</div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
		<p align="right">HT80-NG608-1 E<br />
        <img class="footer"  alt="QTI Logo" src="qti_logo_HTML.png" />
		</p>
		</li>
  </ul>
</div>
</body>
</html>
