<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2010-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 header.html - Header file used to customize the headers on each HTML page for the API 
               Interface Specification documents.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1.
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support Rev E Alpha process using Doxygen 1.8.2 -->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Multicore Asynchronous Runtime Environment Tasks</title><!--END !PROJECT_NAME-->
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multicore Asynchronous Runtime Environment
   &#160;<span id="projectnumber">HT80-NG608-1 E</span>
   </div>
  </td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1-QCOM -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="revision_history.html"><span>Revision&#160;History</span></a></li>
      <li><a href="introduction.html"><span>Introduction</span></a></li>
      <li><a href="usergroup0.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="usergroup1.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup3.html"><span>Tutorials</span></a></li>
      <li><a href="usergroup4.html"><span>Reference&#160;Manual</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tasks.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tasks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MARE programmers must partition their application into independent units of work that can be executed asynchronously. Those units of work are called *tasks*. Tasks can be of arbitrary size, although the task granularity affects performance (see <a class="el" href="tasks.html#task_size">Choosing the Right Granularity for a Task</a>). In MARE, each task can have predecessors and successors. The predecessors of a task <code>T</code> are the tasks that must complete before <code>T</code> can execute. Conversely, the sucessors <code>T</code> are the set of tasks that will execute only after <code>T</code> has completed its execution.</p>
<p>Tasks do not execute when they are created. Instead, they must be launched to be executed. Launching a task means that the programmer has finished adding predecessors to it and that she wants the MARE runtime to execute this task as soon as possible. Tasks can be launched into groups, which are sets of tasks that can be waited on, or canceled at once. For information about groups, see <a class="el" href="groups.html#Groups">Groups</a>.</p>
<p>Managing the lifetime of an object in a parallel application can be challenging. This is why MARE automatically destroys tasks once they execute and all references are no longer in scope.</p>
<h1><a class="anchor" id="creating-tasks"></a>
Task Creation</h1>
<p>MARE offers two templated methods to create tasks:</p>
<ol type="1">
<li><code>template&lt;typename Body&gt; <a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> mare::create_task(Body&amp;&amp;)</code></li>
<li><code>template&lt;typename Body&gt; void mare::launch(mare::group_ptr const&amp;, Body&amp;&amp;)</code></li>
</ol>
<p>The first one creates a task and returns a pointer to it. The second one creates a task and launches it into a group. In both cases, the tasks execute the <code>Body</code> passed as a parameter. The preferred type of <code>&lt;typename Body&gt;</code> in both template methods is a lambda expression, although it is possible to use other types such as function objects and function pointers.</p>
<p>Using <code>mare::launch(mare::group_ptr const&amp;, Body&amp;&amp;)</code> is the fastest way to create tasks in MARE and should be used as often as possible. For more information about groups, see <a class="el" href="groups.html">Groups</a>.</p>
<h2><a class="anchor" id="creating-task-lambda"></a>
Create Tasks Using Lambda Expressions</h2>
<p>Lambda expressions are a new feature in C++11, and the preferred argument type to <code>template&lt;typename Body&gt; <a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> mare::create_task(Body&amp;&amp;)</code> and <code>template&lt;typename Body&gt; void mare::launch(mare::group_ptr const&amp;, Body&amp;&amp;)</code>.</p>
<p>Lambda expressions are unnamed function objects that are able to capture variables from the enclosing scopes. A description of this C++11 feature is outside the scope of this document. Find detailed information about lambda expressions in the following links:</p>
<ul>
<li><a href="http://blog.smartbear.com/software-quality/bid/234042/C-11-Tutorial-Lambda-Expressions-The-Nuts-and-Bolts-of-Functional-Programming">C++11 Tutorial: Lambda Expressions â€” The Nuts and Bolts of Functional Programming</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions </a></li>
<li><a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">Lambda Functions in C++11 - the Definitive Guide </a></li>
<li><a href="http://www.youtube.com/watch?v=tLp6ZBHwvj4">Michael Caisse: Lambda Functions</a></li>
</ul>
<p>The following code uses a lambda expression to create a task <code>t1</code> that prints 'Hello World!':</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create task that prints Hello World!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div>
</div><!-- fragment --><p>Alternatively, you could create the task using <code>template&lt;typename Body&gt; void mare::launch(mare::group_ptr const&amp;, Body&amp;&amp;)</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create and launch a task into group g that prints Hello World!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, [] {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div>
</div><!-- fragment --><p>The lambda expression in the previous example is very simple as it does not capture any variables. Let's suppose that you want to capture a string with the user name to do a proper greeting:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create and launch task into group g that prints Hello World!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  std::string name = get_user_name();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, [name] {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      printf(<span class="stringliteral">&quot;Hello World, %s!\n&quot;</span>, name.c_str());</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    });</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --><p>By capturing <code>name</code> in the lambda expression, we make sure that we can use it when the task executes, which happens outside the scope where the task is created. Make sure that, if you capture variables by reference, the original object still exists when the task executes. For example, consider the following code:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create and launch a task into group g that prints Hello World!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  std::string name = get_user_name();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a> (g, [&amp;name] {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      printf(<span class="stringliteral">&quot;Hello World, %s!\n&quot;</span>, name.c_str());</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    });</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --><p>The string <code>name</code> goes out-of-scope in line 7, and its destructor is called then. If the scheduler executes the task after that happens, the program will most likely crash.</p>
<p>Please refer to <a class="el" href="tasks.html#task_ptrs">The task_ptr and unsafe_task_ptr pointers</a> for information about capturing <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> by reference and why you should never do it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Using *default capture* by copy (<code>[=]</code>) or by reference (<code>[&amp;]</code>) will capture all variables from the enclosing scope, which may increase the size of your tasks considerably if the compiler cannot figure out that many of them are not used and do not need to be captured. We recommend that you capture only the variables that your lambda expression uses.</dd></dl>
<h2><a class="anchor" id="creating-task-classes"></a>
Create Tasks Using Classes</h2>
<p>You can use any custom class as <code>&lt;typename Body&gt;</code> by overloading the class's <code>operator()</code>. Notice that the <code>operator()</code> cannot have any arguments. The following code shows how to create a task from a class instance. When the MARE scheduler executes the task, the <code>operator()</code> method is called.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">class </span>user_class {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  user_class(<span class="keywordtype">int</span> value)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    :x(value) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  }</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  <span class="keywordtype">void</span> operator()() {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    printf(<span class="stringliteral">&quot;x = %d\n&quot;</span>, x);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  }</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  <span class="keywordtype">void</span> set_x(<span class="keywordtype">int</span> value) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    x = value;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  }</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  <span class="keywordtype">int</span> x;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;};</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, user_class(42));</div>
</div><!-- fragment --><p>It is also possible to create an object from <code>user_class</code> and then create a task using that object:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create task using a class</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;user_class obj(42);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(obj);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, t);</div>
</div><!-- fragment --><p>The previous example raises an interesting question: What would the task print if we called <code>obj.set_x(100)</code> between lines 3 and 4?</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create task using a class</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;user_class obj(42);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(obj);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;obj.set_x(100);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, t);</div>
</div><!-- fragment --><p>As always, the answer to the ultimate question of life, the universe, and everything is <code>42</code>. The reason is that MARE makes a copy of <code>obj</code> when it creates the task in line 3. Otherwise, users would need to keep track of the lifetime of the objects used to create tasks. However, if you were to construct the object in-place, no copies would be made:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create task using a class</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(user_class(42));</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(g, t);</div>
</div><!-- fragment --><h2><a class="anchor" id="creating-task-fp"></a>
Create Tasks Using Function Pointers</h2>
<p>The last way to create a task is by using a function pointer. As with lambda expressions and classes, the function passed as parameter cannot take any arguments:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keywordtype">void</span> foo() {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Create task that executes foo()</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(foo);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Due to limitations in the Visual Studio C++ compiler, this does not work on Visual Studio. You can get around it by using a lambda function:</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keywordtype">void</span> foo() {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;};</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Create task that executes foo()</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    foo();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  });</div>
</div><!-- fragment --><h2><a class="anchor" id="task_ptrs"></a>
The task_ptr and unsafe_task_ptr pointers</h2>
<p>The method <code>mare::create_task(Body&amp;&amp;)</code> returns an object of type <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code>, which is a custom smart pointer to the task object.</p>
<p>Tasks are reference-counted, so they are automatically destroyed when no more <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> pointers reference them. When a task is launched, MARE runtime increases the reference counter of the task. This prevents the task from being destroyed, even if all pointers referencing the task are reset. The MARE runtime decrements the reference counter of the task after it completes execution.</p>
<p>The task reference counter requires atomic operations. Copying a <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> causes an atomic increment and the new copy of the <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> causes an atomic decrement when it goes out of scope. For best results, minimize the times your application copies <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> pointers.</p>
<p>Some algorithms require constantly passing <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> pointers. To prevent a decrease in performance, MARE provides another task pointer type that does not perform reference counting: <code><a class="el" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a></code>.</p>
<p>The following example demonstrates how to point <code><a class="el" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a></code> to a task:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Create task that prints Hello World!</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  });</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// Get unsafe_task_ptr pointing to task</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a> unsafe_t1 = t1.<a class="code" href="group__tasks__doc.html#a0e0b2b99756e2b44ed6dcafc759c09e0">get</a>();</div>
</div><!-- fragment --> <p style="margin-left:.5in; text-indent:-.5in"><b>Note:&nbsp;</b> Task lifetime is determined by the number of <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> referencing it. Programmers must ensure that there is always a valid <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> while using a <code><a class="el" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a></code>, otherwise it will lead to memory corruption and/or segmentation fault.</p>
<p>You can use a <code><a class="el" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a></code> in any API method in which you can use a <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code>, with the exception of <code>mare::launch_and_reset(mare::task_ptr&amp;)</code>.</p>
<p>It is incorrect to reference a MARE <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> like the following example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>( [&amp;t1] {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t2!\n&quot;</span>);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  });</div>
</div><!-- fragment --><p>Instead, copy the pointer</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>( [t1] {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t2!\n&quot;</span>);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  });</div>
</div><!-- fragment --><p>Or use a <code><a class="el" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a></code> (of course, make sure that <code>t1</code> does not go out of scope):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1unsafe__task__ptr">mare::unsafe_task_ptr</a> unsafe_t1= t1.<a class="code" href="group__tasks__doc.html#a0e0b2b99756e2b44ed6dcafc759c09e0">get</a>();</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([unsafe_t1] {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t2!\n&quot;</span>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  });</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t3 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([&amp;unsafe_t1] {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t3!\n&quot;</span>);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  });</div>
</div><!-- fragment --><h1><a class="anchor" id="creating_dependencies"></a>
Create Dependencies Between Tasks</h1>
<p>Use the following methods to specify the order of task execution:</p>
<ul>
<li><code>void mare::before(mare::task_ptr const&amp;, mare::task_ptr const&amp;)</code></li>
<li><code>void mare::after(mare::task_ptr const&amp;, mare::task_ptr const&amp;)</code></li>
</ul>
<p>The following example shows how to use <code>mare::after</code> to ensure that task <code>t1</code> executes before task <code>t2</code>. The MARE runtime guarantees that <code>t2</code> does not begin execution until <code>t1</code> completes execution, regardless of how many hardware execution contexts are available in the system.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello &quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(<span class="stringliteral">&quot;World!\n&quot;</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Make sure that t1 executes before t2</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t1, t2);</div>
</div><!-- fragment --><p>The previous example is equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello &quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(<span class="stringliteral">&quot;World!\n&quot;</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Make sure that t1 executes before t2</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__dependencies.html#ga5380533974751674726d9899ecb99d22">mare::before</a>(t2, t1);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Alternatively, you can use <code> operator&gt;&gt; </code> instead of <code>mare::after</code> and <code> operator&lt;&lt; </code> instead of <code>mare::before</code>:</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello &quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(<span class="stringliteral">&quot;World!\n&quot;</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Make sure that t1 executes before t2</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;t1 &gt;&gt; t2;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
</div><!-- fragment --><p>Because tasks can have multiple successors and predecessors, you can use <code>mare::before</code> and <code>mare::after</code> to create DAGs:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{ printf(<span class="stringliteral">&quot;Task t1\n&quot;</span>);});</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{ printf(<span class="stringliteral">&quot;Task t2\n&quot;</span>);});</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t3 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{ printf(<span class="stringliteral">&quot;Task t3\n&quot;</span>);});</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t4 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{ printf(<span class="stringliteral">&quot;Task t4\n&quot;</span>);});</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// Make sure that t1 executes before t2 and t3.</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">// t2 and t3 may execute concurrently</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// t4 executes only after t2 and t3 have completed.</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t1, t2);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t1, t3);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t2, t4);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t3, t4);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>A cycle in the DAG may cause deadlock. For performance reasons, MARE does not check whether there are cycles in the DAG. The programmer is responsible for avoiding them.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello &quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    printf(<span class="stringliteral">&quot;World!\n &quot;</span>);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  });</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// Create a cycle in the DAG:</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t1, t2);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t2, t1);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// It will never return</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t1);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
</div><!-- fragment --><p>In the previous example, <code>mare::wait_for(t1)</code> will never return because <code>t1</code> needs <code>t2</code> to complete before it can execute. However, <code>t2</code> will never execute because it needs <code>t1</code> to execute first.</p>
<h1><a class="anchor" id="sec_task_storage"></a>
Task Storage</h1>
<h2><a class="anchor" id="task_local_storage"></a>
Task-Local Storage</h2>
<p>Tasks, much like threads, can be associated with task-local storage, via <code><a class="el" href="group__task__storage.html#classmare_1_1task__storage__ptr">mare::task_storage_ptr</a></code>. The usage pattern consists of declaring a global variable, say <code>storage</code>, which holds a pointer to the actual task-local data. Then, within a task <code>t</code>, that variable is assigned a pointer to a (usually) local variable, or a chunk of freshly allocated memory. After that, <code>storage</code> can be used within the dynamic extent of task <code>t</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;task_storage_ptr&lt;int&gt; storage;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}; <span class="comment">// namespace</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keywordtype">void</span> func() {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  printf(<span class="stringliteral">&quot;%d\n&quot;</span>, *storage);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  ++*storage;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keywordtype">void</span> run() {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  <span class="keyword">auto</span> g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(g, [i] {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keywordtype">int</span> v = i;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        storage = &amp;v;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        func();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        assert(v == i+1);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        func();</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        assert(v == i+2);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;      });</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  }</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(g);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
</div><!-- fragment --><p>Note that accessing the value of <code>storage</code> affects only the current task. Attempting to modify the value of a <code>task_storage_ptr</code> outside of a task yields undefined behaviour.</p>
<p>Optionally, a destructor (or rather: finalizer), can be employed to dispose resources. The destructor will run within each task, which has a value assigned to the global variable.</p>
<h2><a class="anchor" id="scheduler_local_storage"></a>
Scheduler-Local Storage</h2>
<p>Another use case are scratchpads: data that is persistent across task boundaries, usually to avoid per-task memory allocation or initialization. We can avoid synchronizing access to scratchpads if each scheduler creates its own scratchpad (which can then be used like task-local storage). As further optimization, `scheduler_storage_ptr` are created lazily when they are written to inside of a task. Note that variable initialization and destruction happen through the constructor and destructor of `T`:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;mare/schedulerstorage.hh&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">const</span> scheduler_storage_ptr&lt;size_t&gt; s_sls_state;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}; <span class="comment">// namespace</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordtype">void</span> run() {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  <span class="keyword">auto</span> g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 200; ++i) {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(g, [i] {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        <span class="keywordtype">size_t</span> c = ++*s_sls_state;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="comment">// values for c are consecutive on a per-scheduler basis</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;      });</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(g);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div>
</div><!-- fragment --><p>Scheduler-local storage is unaffected by context switches (e.g., via <code>wait_for</code>, or <code>yield</code>).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;mare/schedulerstorage.hh&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">const</span> scheduler_storage_ptr&lt;size_t&gt; s_sls_state;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}; <span class="comment">// namespace</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordtype">void</span> run() {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  <span class="keyword">auto</span> g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  <span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">create_task</a>([] {});</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 200; ++i) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(g, [=] {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keywordtype">size_t</span> c1 = ++*s_sls_state;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(t);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(t);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordtype">size_t</span> c2 = ++*s_sls_state;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        assert(c1 + 1 == c2);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      });</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  }</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(g);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
</div><!-- fragment --><p>A complete example </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &lt;mare/mare.h&gt;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#include &lt;mare/schedulerstorage.hh&gt;</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">using namespace </span>mare;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">struct </span>image_scratchpad {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  image_scratchpad() {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::fill(begin(edge_image), end(edge_image), 0);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  <span class="keywordtype">char</span> edge_image[N];</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;};</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="keyword">const</span> <a class="code" href="group__scheduler__storage.html#classmare_1_1scheduler__storage__ptr">scheduler_storage_ptr&lt;image_scratchpad&lt;4096&gt;</a> &gt; image_buffers;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;}; <span class="comment">// namespace</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keywordtype">void</span> run() {</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <span class="keywordtype">int</span> <span class="keyword">const</span> N = 200;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keyword">auto</span> g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; N; ++i) {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(g, [i] {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <span class="comment">// fill image buffer, which is reused across tasks</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; slot : image_buffers-&gt;edge_image)</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;          slot = i &amp; 0xff;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        internal::yield(); <span class="comment">// context-switch, we expect SLS to survive this</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="comment">// check contents</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        for (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; slot : image_buffers-&gt;edge_image)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;          assert(slot == <span class="keywordtype">char</span>(i &amp; 0xff));</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      });</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(g);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div>
</div><!-- fragment --><h2><a class="anchor" id="thread_local_storage"></a>
Thread-Local Storage</h2>
<p>If a group of tasks needs scratchpads, but does not require that data persists across context switching, <code>thread_storage_ptr</code> is a viable alternative to <code>scheduler_storage_ptr</code>. Since MARE Thread-Local Storage is tied to MARE's device thread, we allocate fewer instances of `T` (compared to <code>scheduler_storage_ptr</code>, see earlier example), at most one per device thread.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;mare/threadstorage.hh&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">namespace </span>{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">const</span> thread_storage_ptr&lt;size_t&gt; s_tls_state;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}; <span class="comment">// namespace</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordtype">void</span> run() {</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  <span class="keyword">auto</span> g = <a class="code" href="group__groups__creation.html#ga164f9c8b577069b2d8b1634cde459b1e">create_group</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  <span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">create_task</a>([] {});</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 200; ++i) {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(g, [=] {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <span class="keywordtype">size_t</span>* p1 = s_tls_state.get();</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">launch</a>(t);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(t);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordtype">size_t</span>* p2 = s_tls_state.get();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="comment">// cannot assume that p1 == p2</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      });</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  }</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">wait_for</a>(g);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
</div><!-- fragment --><h1><a class="anchor" id="launching_tasks"></a>
Launching Tasks</h1>
<p>Tasks do not execute unless they are launched. In <a class="el" href="groups.html#Groups">Groups</a> we describe how to create and launch tasks using <code>template&lt;typename Body&gt; void mare::launch(<a class="el" href="group__groups__doc.html#classmare_1_1group__ptr">mare::group_ptr</a> const&amp;, Body&amp;&amp;)</code>. Tasks launched in this way execute as soon as hardware contexts are available.</p>
 <p style="margin-left:.5in; text-indent:-.5in"><b>Note:&nbsp;</b> <code>mare::launch(mare::group_ptr const&amp;, Body&amp;&amp;)</code> does not provide a <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> and therefore become anonymous and cannot be part of a DAG.</p>
<p>Tasks that are part of a DAG must be created using <code>template&lt;typename Body&gt; <a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> mare::create_task(Body&amp;&amp;)</code>. This template method returns a task pointer that is used to set up dependencies between tasks. Once a the dependencies of a task are set, <code>void mare::launch(<a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> const&amp;)</code> launches it:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//...</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// Set up dependencies</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">// ..</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// t1 is ready, launch it</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
</div><!-- fragment --><p>The method <code>void mare::launch(mare::task_ptr const&amp;)</code> informs the MARE runtime that the task is ready to execute as soon as a hardware context is available *and* after all its predecessors have executed. In the following example, task <code>t2</code> launches, but it will never execute because its predecessor <code>t1</code> has not executed, and therefore, this task will not execute:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t2!&quot;</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<a class="code" href="group__dependencies.html#gab0a753d6b37824e4b5349c411b155ca2">mare::after</a>(t1, t2);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//wait_for will never return because t2 won&#39;t execute until t1</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//does. However, t1 hasn&#39;t been launched.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t2);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
</div><!-- fragment --><p>Notice that launching a task means that it is not possible to add any new predecessors, although you can add successors. The reason is that, by launching the task, the programmer is asking the MARE runtime to execute the task as soon as possible. By the time the programmer tries to add a new predecessor to the task, the task might have already executed, and adding a predecessor to an already-executed task is not allowed.</p>
<p>Tasks can launch only once. Any subsequent calls to <code><a class="el" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch()</a></code> do not cause the task to execute again. The calls might, however, cause the task to be added to new groups. See <a class="el" href="groups.html#Groups">Groups</a>.</p>
<h2><a class="anchor" id="launch_and_reset"></a>
Launch and Reset</h2>
<p>If <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> will not be used after launching a task, consider using <code> launch_and_reset(mare::task_ptr)</code> instead of <code>launch(mare::task_ptr)</code>. The <code> launch_and_reset(mare::task_ptr)</code> function launches the task and resets the <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> pointer in a single step. In this case, if there is only one <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code>, the MARE runtime assumes it is the sole owner of the task and does not need to protect access to it, thereby improving overall performance.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//assert will not fire</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;assert(t != <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<a class="code" href="group__execution.html#ga40aa3b0fcca0613706a53324a87f2926">mare::launch_and_reset</a>(t);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//assert will not fire</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;assert(t == <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="wait_for_task"></a>
Waiting For a Task</h1>
<p>The method <code>wait_for(mare::task_ptr const&amp;)</code> does not return until the task that passed as an argument completes execution. It returns immediately once the task completes or cancels.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t1); <span class="comment">//won&#39;t return until t1 has executed</span></div>
</div><!-- fragment --> <p style="margin-left:.5in; text-indent:-.5in"><b>Note:&nbsp;</b> If <code>wait_for(mare::task_ptr const&amp;)</code> is called from within a task, MARE context-switches the task and finds another one to run. If called from outside a task (i.e., the main thread), MARE blocks the thread until <code>wait_for(mare::task_ptr const&amp;)</code> returns (see <a class="el" href="issues.html">Interoperability</a>).</p>
<p>Both <code>mare::wait_for(mare::task_ptr const&amp;)</code> and <code>mare::wait_for(mare::unsafe_task_ptr)</code> are safe points. For information about safe points, see <a class="el" href="issues.html">Interoperability</a>.</p>
<h1><a class="anchor" id="task_cancelation"></a>
Canceling a Task</h1>
<p>There are three main ways to cancel an individual task. First, if you have a pointer to the task, you can use <code>mare::cancel(mare::task_ptr)</code>. Second, to cancel a running task from within the task body, call <code><a class="el" href="group__tasks__cancelation.html#ga2ef5a64e289ff4f2339b846066d4a052">mare::abort_task()</a></code>. And third, an unlaunched task is canceled when every <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code> pointing to the task goes out-of-scope. In this section, we examine each of these cancelation methods in detail.</p>
<h2><a class="anchor" id="mare_cancel"></a>
mare::cancel</h2>
<p>Use <code>mare::cancel(mare::task_ptr const&amp;)</code> &mdash; or <code>mare::cancel(mare::unsafe_task_ptr)</code> &mdash; to cancel a task and its successors. What happens to the task when the programmer calls <code>mare::cancel(mare::task_ptr const&amp;)</code> depends on the status of task.</p>
<h3><a class="anchor" id="canceling_a_not_running_task"></a>
Canceling a Task Before It Executes</h3>
<p>If a task is canceled before it is launched, it never executes, even if it is launched later. In addition, the runtime will then cancel all successors and descendents, this is called "cancelation
propagation". In the following example, we create two tasks <code>t1</code> and <code>t2</code> and create a dependency between them. Notice that, if any of the tasks execute, it will raise an assertion. In line 13, we cancel <code>t1</code>, which causes <code>t2</code> to be canceled as well. In line 16, we launch <code>t2</code>, but this has no effect because the task will not execute, as it was canceled when <code>t1</code> propagated its cancelation.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">auto</span> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Create dependencies</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;t1 &gt;&gt; t2;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">// Cancel t1, which propagates cancelation to t2</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t1);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// Launch t2. Does nothing, t2 got canceleded via cancelation propagation</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">// Returns immediately, t2 is canceled.</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t2);</div>
</div><!-- fragment --><p>Similarly, if a task is canceled after it is launched, but before it starts executing, it never executes and will propagate the cancelation request to its successors. In the following example, we create and chain three tasks, <code>t1</code>, <code>t2</code> and <code>t3</code>. In line 18, we launch <code>t2</code>, but it cannot execute because its predecessor has not yet executed. In line 21, we cancel <code>t2</code>, which means that it will never execute. Because <code>t3</code> is <code>t2</code>'s successor, it is also canceled - if <code>t3</code> had a successor, it would also be canceled.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">auto</span> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">auto</span> t3 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  });</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// Create dependencies</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;t1 &gt;&gt; t2 &gt;&gt; t3;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// Launch t2. It can&#39;t execute yet because</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// t1 hasn&#39;t been launched.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// Cancel t2, which propagates cancelation to t3</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t2);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">// Launch t1. It will execute because nobody</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">// canceled it.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">// Returns after t1 completes execution</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t1);</div>
</div><!-- fragment --><h3><a class="anchor" id="canceling_a_running_task"></a>
Canceling a Task While It Executes</h3>
<p>Canceling a task that is executing is more involved because MARE uses <a href="http://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking.2Ftime-sharing">cooperative multitasking </a>. This means that, once a task is executing, it is not pre-empted unless it voluntarily cedes the processor (i.e., by calling <code>mare::wait_for(mare::task_ptr const&amp;)</code>). Thus, it is up to the task to check periodically whether or not it has been canceled. Use <code><a class="el" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel()</a></code> inside a task body to abort the task immediately if the task, or any of the groups to which it belongs, have been canceled.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="keywordflow">while</span>(1) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;      <a class="code" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel</a>();</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      printf(<span class="stringliteral">&quot;Waiting to be canceled.\n&quot;</span>);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      usleep(10);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    }</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    assert(<span class="keyword">false</span>); <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  }</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  );</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//Launch t</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// Wait for 2 seconds.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;sleep(2);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// Cancel task. Returns immediately.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// Wait for the task.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
</div><!-- fragment --><p>In the example above, task <code>t</code> will never finish unless it is canceled. Task <code>t</code> is launched in line 12. After launching the task, we block for 2 seconds in line 15 to make sure that <code>t</code> is scheduled and prints its messages. In line 18, we ask MARE to cancel the task, which should be running by now. The method <code><a class="el" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel()</a></code> returns immediately after it marks the task as "pending for cancelation". This means that <code>t</code> might still be executing after <code>mare::cancel(t)</code> returns. That is why we call <code>mare::wait_for(t)</code> in line 21, to makes sure we wait for <code>t</code> to complete its execution.</p>
<dl class="section note"><dt>Note</dt><dd>We should stress that a task does not know whether someone has requested its cancelation unless it calls <code><a class="el" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel()</a></code> during its execution.</dd></dl>
<p>The method <code><a class="el" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel()</a></code> never returns if the task has indeed been canceled because it throws an exception that the MARE runtime catches. For this reason, we recommend that you use <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">Resource Acquisition Is Initialization (RAII)</a> to allocate and deallocate the resources used inside a task. If using RAII in your code is not an option, surround <code><a class="el" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel()</a></code> with <code>try - catch</code>, and call <code>throw</code> from within the <code>catch</code> block after the cleanup code:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="keywordflow">while</span>(1) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;      <span class="keywordflow">try</span>{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        <a class="code" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel</a>();</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      }<span class="keywordflow">catch</span>(<a class="code" href="group__exceptions.html#classmare_1_1abort__task__exception">mare::abort_task_exception</a> <span class="keyword">const</span>&amp; e) {</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        <span class="comment">//..do cleanup</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        <span class="keywordflow">throw</span>;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      }</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      printf(<span class="stringliteral">&quot;Waiting to be canceled.\n&quot;</span>);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      usleep(10);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    }</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    assert(<span class="keyword">false</span>); <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  }</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  );</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">//Launch t</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// Wait for 2 seconds.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;sleep(2);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">// Cancel task. Returns immediately.</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">// Wait for the task to complete.</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t);</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>If we replace <code>throw</code> in line 7 of the previous example with <code>return</code>, the exception would not propagate to the runtime, MARE would not consider the task as canceled, and, therefore, its successors (if any) would not be canceled.</dd></dl>
<h3><a class="anchor" id="canceling_a_done_task"></a>
Canceling a Task After It Completes Execution</h3>
<p>Canceling a task after it has been executed has no effect on the task, nor on its successors. In the following example, we launch <code>t1</code> and <code>t2</code> after we set up a dependency between them. On line 25, we cancel <code>t1</code> after it has completed. By then, <code>t1</code> has finished execution (we wait for it in line 21) so <code>cancel(t1)</code> has no effect. Thus, nobody cancels <code>t2</code> and <code>wait_for(t2)</code> in line 28 never returns.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  });</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">auto</span> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    <span class="keywordflow">while</span> (1){</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      <a class="code" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel</a>();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;      printf(<span class="stringliteral">&quot;Hello World from t1!\n&quot;</span>);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      usleep(100);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    };</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  });</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// Create dependencies</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;t1 &gt;&gt; t2;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// Launch tasks</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// Wait for t1 to complete</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t1);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">// Cancel t1. Because it has already completed, it does not do</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">// cancelation propagation.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t1);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">// Will never return</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t2);</div>
</div><!-- fragment --><h2><a class="anchor" id="mare_abort_task"></a>
mare::abort_task()</h2>
<p>Running tasks call <code><a class="el" href="group__tasks__cancelation.html#ga2ef5a64e289ff4f2339b846066d4a052">mare::abort_task()</a></code> to cancel themselves and their successors. Consider the following example. We create two tasks, <code>t1</code> and <code>t2</code>, and create a dependency between them. The body of <code>t1</code> is very simple: it prints a message 10 times and then it aborts. We launch both and wait for <code>t1</code> to complete its execution in line 26. Because <code>t1</code> calls <code><a class="el" href="group__tasks__cancelation.html#ga2ef5a64e289ff4f2339b846066d4a052">mare::abort_task()</a></code>, it is canceled and propagates its cancelation to its successor,<code>t2</code>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([]{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      printf(<span class="stringliteral">&quot;Hello World %d\n&quot;</span>, i);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      sleep(1);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      i++;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;      <span class="keywordflow">if</span>(i == 10)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        <a class="code" href="group__tasks__cancelation.html#ga2ef5a64e289ff4f2339b846066d4a052">mare::abort_task</a>();</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    }</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  });</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="keyword">auto</span> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  });</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;t1 &gt;&gt; t2;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">//Launch tasks</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t1);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">// Wait for t1 to complete.</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t1);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">// Returns immediately, t2 is canceled.</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t2);</div>
</div><!-- fragment --><h2><a class="anchor" id="task_abandonment"></a>
Cancelation by Abandonment</h2>
<p>When all the <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a></code>s referencing an unlaunched task go out of scope, the task is canceled and it propagates the cancelation to its successors. The reasoning is simple: a task <code>t</code> cannot launch without a task pointer, and none of its successors will ever be able to execute because <code>t</code> never executed.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keywordtype">void</span> foo()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  <span class="keyword">auto</span> t1 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;      printf(<span class="stringliteral">&quot;Hello World from t1\n&quot;</span>);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    });</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  <span class="keyword">auto</span> t2 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      printf(<span class="stringliteral">&quot;Hello World from t2\n&quot;</span>);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;      <span class="comment">// This will never fire</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;      assert(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    });</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  <span class="keyword">auto</span> t3 = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>([] {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;      <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;      <span class="keywordflow">while</span>(i++ &lt; 10)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;      {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        printf(<span class="stringliteral">&quot;Hello World from t3\n&quot;</span>);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        sleep(1);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;      };</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    });</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  t1 &gt;&gt; t2;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t2);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t3);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="comment">//t1, t2 and t3 go out of scope</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
</div><!-- fragment --><p>In the snippet above, we create three tasks <code>t1</code>, <code>t2</code> and <code>t3</code>, and create a dependency between the first two. We launch <code>t2</code> and <code>t3</code> in lines 26 and 27. <code>t2</code> cannot run because <code>t1</code> has not yet executed. In line 30, foo() ends and the three pointers go out-of-scope. <code>t1</code> is canceled because it is not yet launched. <code>t2</code> is canceled because <code>t1</code> propagated its cancelation. <code>t3</code> does not get canceled and will run even after <code>foo()</code> goes out-of-scope.</p>
<h1><a class="anchor" id="task_attributes"></a>
Task Attributes</h1>
<p>Programmers can decorate tasks with attributes that help MARE make better scheduling decisions. The current MARE release supports just one attribute, but there are plans to include others in future releases.</p>
<h2><a class="anchor" id="using_task_attrs"></a>
Using Task Attributes</h2>
<p>Use the template method <code>template &lt;typename Attribute, typename ...Attributes&gt; <a class="el" href="group__tasks__doc.html#classmare_1_1task__attrs">mare::task_attrs</a> mare::create_task_attrs(Attribute const&amp;, Attributes const&amp; ...)</code> to create an object of type <code><a class="el" href="group__tasks__doc.html#classmare_1_1task__attrs">mare::task_attrs</a></code> that summarizes all of the attributes of the task. In the following code snippet, we create a <code>task_attrs</code> object that includes the <code>mare::blocking</code> attribute.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__attrs">mare::task_attrs</a> attrs = <a class="code" href="group__attributes.html#ga237e838bcedc75fcfb2f96ad604f1ea0">mare::create_task_attrs</a>(<a class="code" href="group__attributes.html#ga864b6da129cad4e6903c8935ff801e0f">mare::attr::blocking</a>);</div>
</div><!-- fragment --><p>Task attributes can be applied only when the task is created using the template method <code>mare::with_attrs(...)</code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">auto</span> body = []{ printf(<span class="stringliteral">&quot;Hello World from t&#39;s task body!\n&quot;</span>);};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">auto</span> cancel_handler = [] {printf(<span class="stringliteral">&quot; Hellow World from t&#39;s cancel handler!\n&quot;</span>);};</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__attrs">mare::task_attrs</a> attrs = <a class="code" href="group__attributes.html#ga237e838bcedc75fcfb2f96ad604f1ea0">mare::create_task_attrs</a>(<a class="code" href="group__attributes.html#ga864b6da129cad4e6903c8935ff801e0f">mare::attr::blocking</a>);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<a class="code" href="group__tasks__doc.html#classmare_1_1task__ptr">mare::task_ptr</a> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(<a class="code" href="group__tasks__doc.html#ga25f7bf623d3276d3f8ef7be928009650">mare::with_attrs</a>(attrs, body,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                                      cancel_handler));</div>
</div><!-- fragment --><p>In the example above we create two lambda methods: <code>body</code> and <code>cancel_handler</code>. The reason we need the latter is explained below.</p>
<h2><a class="anchor" id="blocking_task"></a>
Attribute: Blocking Task</h2>
<p>A blocking task is defined as a task that depends on external (non-MARE) synchronization to make guaranteed forward progress. Typically, this includes completing I/O requests and other OS syscalls with indefinite run-time, but also busy-waiting. It does not include waiting on MARE tasks or groups using <code>mare::wait_for</code>.</p>
<p>There are two problems with blocking tasks. The first is that once a task executes, it will take over a thread in a MARE thread pool, thus preventing other tasks from executing in the same thread. Because a blocking task spends most of its time blocking on an event, we are essentially wasting one of the threads in the thread pool. When the programmer decorates a task with the <code>mare::attr::blocking</code> attribute, MARE makes sure that the thread pool does not waste a thread to the task.</p>
<p>The second problem has to do with cancelation. If a blocking task is canceled while it is waiting on an external event, we need to be able to wake the task up so that it can execute <code>mare::abort_on_cancel</code>. This is why blocking tasks require an extra lambda function, called the "cancel handler". A task's cancel handler is executed only once, and only if the task is running. In the following example, we create a blocking task using two lambdas, <code>body</code> and <code>cancel_handler</code>. After launching <code>t</code> and sleeping for a couple of seconds, we cancel it (line 30). Most likely, by the time we cancel <code>t</code>, it will be waiting on the condition variable. The cancel handler function calls wakes up the task body so that it can abort (line 10).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">static</span> std::mutex mutex;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">static</span> std::condition_variable cv;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">auto</span> attrs = <a class="code" href="group__attributes.html#ga237e838bcedc75fcfb2f96ad604f1ea0">mare::create_task_attrs</a>(<a class="code" href="group__attributes.html#ga864b6da129cad4e6903c8935ff801e0f">mare::attr::blocking</a>);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">auto</span> body = [] {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  printf(<span class="stringliteral">&quot;START  blocking task\n&quot;</span>);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  std::unique_lock&lt;std::mutex&gt; lock(mutex);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  <span class="keywordflow">for</span> (;;) {</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <a class="code" href="group__tasks__cancelation.html#gad97de382780eb082e5341a23cf45dec9">mare::abort_on_cancel</a>();</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    cv.wait(lock);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  }</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  printf(<span class="stringliteral">&quot;STOP blocking task\n&quot;</span>);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">auto</span> cancel_handler = [] {</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  printf(<span class="stringliteral">&quot;CANCEL blocking task\n&quot;</span>);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  std::lock_guard&lt;std::mutex&gt; lock(mutex);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  cv.notify_all();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;};</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">auto</span> t = <a class="code" href="group__tasks__creation.html#ga4d2a57c19a9199c7ccee7a01ff688da8">mare::create_task</a>(<a class="code" href="group__tasks__doc.html#ga25f7bf623d3276d3f8ef7be928009650">mare::with_attrs</a>(attrs, body, cancel_handler));</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<a class="code" href="group__sdf__doc.html#gaf6d88ec9965da7eaa9da60ab7c27041b">mare::launch</a>(t);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// Wait for task to block</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;sleep(2);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">// Cancel task. It will call t&#39;s cancel_handler</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<a class="code" href="group__groups__cancel.html#ga432f04a0f64afdd64f3b83000bddc042">mare::cancel</a>(t);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">//Wait for t to complete</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<a class="code" href="group__groups__waiting.html#gaa2a0ab6d7f24ae0840b581bfa8e94fea">mare::wait_for</a>(t);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div>
</div><!-- fragment --><h1><a class="anchor" id="task_size"></a>
Choosing the Right Granularity for a Task</h1>
<p>The performance of MARE applications is subject to all the issues discussed in <a class="el" href="pp.html">Parallel Processing Tutorial</a>. In this section, we discuss one of these particular issues, the task granularity. The MARE runtime has certain overheads introduced by the need to manage and schedule tasks properly, while respecting all dependencies, and ensuring that tasks can be executed concurrently. The programmer can amortize the overheads of the MARE runtime by following the simple guidelines presented here.</p>
<p>Programmers can control two key aspects that significantly affect application performance: task granularity (the amount of work in a task) and number of tasks in the application. Obviously, these two aspects are correlated, since the amount of work that the application performs should be the same, regardless of partitioning. Programmers must make the following tradeoff: the larger the number of tasks and the finer the granularity, the more overhead in the runtime to amortize. The smaller the number of tasks (and thus the coarser the granularity), the less concurrency available for the runtime to exploit.</p>
<p>To maximize performance, programmers should follow three basic guidelines:</p>
<ol>
<li>
<p class="startli">Consider the total amount of work in the application: If the work is trivial, the effort of parallelization may not pay off from a performance standpoint. Other metrics, such as energy consumption may benefit from multicore utilization. However, the total amount of work should at least compensate for the overhead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Consider the degree of parallelism: The more independent tasks the runtime has to schedule, the better the utilization of the multicore system. At a minimum, having at least double the number of cores is a good first approximation.</p>
<p class="endli"></p>
</li>
<li>
Consider the granularity of the tasks: As discussed earlier, coarser tasks amortize the overhead of parallelization. Therefore, we recommend tasks to be larger than few microseconds (the actual granularity will depend on the particular platform on which the application is deployed). For tasks larger than 50 microseconds, the overhead is completely amortized even when creating tens of thousands of tasks. </li>
</ol>
 <a class="anchor" id="MARE_Breakeven"></a><br/>
</p>
 <div style="text-align:center;"><img src="MARE_breakeven_HTML.png" alt="MARE Breakeven" width="90%" height="90%"><br/><br/><b>Speedup as a function of task granularity and total number of tasks</b></div><br/> <p>To determine if an application can benefit from parallelization, the figure above plots the speedup that can be obtained as a function of the task granularity. We plot a family of curves, each for a different number of tasks in the application, between 2 and 32768. The tasks defined here are totally independent, representing iterations of an integer kernel with two nested loops. The tasks are launched simultaneously to maximize the pressure on the MARE scheduler. For the plot, we used a Snapdragon 800 platform with MARE running on four cores. On this configuration, the recommended minimum work per task is 10 microseconds. Other platforms will have different breakeven points. Dependencies and group membership will add to the overhead; however, tasks around 10 microseconds will be able to amortize the overhead. This is also an area where we are putting significant effort in optimizing the performance. Therefore, future releases of MARE should expect even better performance at finer granularity. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2012-2013 Qualcomm Technologies, Inc. All rights reserved. 
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 footer.html - footer file used to customize the footers on each HTML page for the API 
               Interface Specification documents.
 Updated:  11/05/13 LB Removed confidential, distribution, and export statement.
 Updated:  09/20/13 LB Updated to support mare project's User Guide and API doc.
 Updated:  04/18/13 LB Added Documentation and Interface Specification in place of hard-coding doc dcn. Deleted original
                       use of Documentation and Interface Specification to display text in the left portion of the footer.
 Updated:  03/08/13 LB Updated to support Doxygen 1.8.3.1
 Updated:  01/18/13 LB Replaced qualcomm_logo.gif to QTI_Logo.png
 Updated:  10/25/12 LB Added company name changes.
 New file: 10/15/12 LB Created to support the Rev E Alpha Doxygen-to-HTML-PDF process. -->
<!-- start footer part -->
<!-- 7/12/12 JG added div class defined in css to include warning statement on all pages -->
<!--[if lte IE 8]><div class="warningmsgie8"><![endif]-->
<!--[if(gte IE 9)|!(IE)]><!--><div class="warningmsg"><!--<![endif]-->
</div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="userguide.html">User Guide</a></li>
    <li class="footer">
		<p align="right">HT80-NG608-1 E<br />
        <img class="footer"  alt="QTI Logo" src="qti_logo_HTML.png" />
		</p>
		</li>
  </ul>
</div>
</body>
</html>
