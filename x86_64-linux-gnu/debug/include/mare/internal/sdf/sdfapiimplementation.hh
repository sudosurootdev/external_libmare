// --~--~--~--~----~--~--~--~----~--~--~--~----~--~--~--~----~--~--~--~--
// Copyright 2013 Qualcomm Technologies, Inc.  All rights reserved.
// Confidential & Proprietary â€“ Qualcomm Technologies, Inc. ("QTI")
// 
// The party receiving this software directly from QTI (the "Recipient")
// may use this software as reasonably necessary solely for the purposes
// set forth in the agreement between the Recipient and QTI (the
// "Agreement").  The software may be used in source code form solely by
// the Recipient's employees (if any) authorized by the Agreement.
// Unless expressly authorized in the Agreement, the Recipient may not
// sublicense, assign, transfer or otherwise provide the source code to
// any third party.  Qualcomm Technologies, Inc. retains all ownership
// rights in and to the software.
// --~--~--~--~----~--~--~--~----~--~--~--~----~--~--~--~----~--~--~--~--
/** @file sdfapiimplementation.hh */
#pragma once

#include <functional>
#include <tuple>
#include <vector>

#include <mare/exceptions.hh>

#include <mare/internal/sdf/channelimplementation.hh>
#include <mare/internal/sdf/sdfnodepolicy.hh>


namespace mare {
namespace internal {


  /// We want to convert convenient API calls of the following form
  ///      create_sdf_node(..., with_inputs(a, b, c,), with_outputs(x, y),
  ///                           with_inputs(m), with_inputs(n, p));
  ///
  /// to the following canonical form, to simplify parameter-processing for
  /// the various create_sdf_node() calls:
  ///      create_sdf_node(..., with_input(a), with_input(b), with_input(c),
  ///                           with_output(x), with_output(y),
  ///                           with_input(m), with_input(n), with_input(p));
  ///
  /// where with_input(..) and with_output(..) represent objects of type
  /// data_channel_access_wrapper (see sdfbasedefs.hh).
  ///
  /// Two mechanisms are implemented below to make this conversion possible
  ///  purely via compile-time templates.
  /// - function flatten_multiple_mdcaws:
  ///     converts a sequence of multiple_data_channel_access_wrapper objects
  ///     into a sequence of data_channel_access_wrapper objects, essentially
  ///     the conversion from the convenient form to the canonical form in the
  ///     above example.
  ///       (please read description in sdfbasedefs.hh before continuing)
  ///
  /// - struct flattened_tdcaw_type_from_mdcaws:
  ///     determines the sequence of user-data-types T1, T2, ... for the
  ///     flattened sequence of channels (data_channel_access_wrapper objects)
  ///     from the sequence of multiple_data_channel_access_wrapper objects.

  /// Helper for flatten_single_mdcaw (a component of flatten_multiple_mdcaws)
template<int index, int remaining, typename MDCAW, typename U, typename ...Us>
typename std::enable_if< (remaining == 1),
                         std::tuple< data_channel_access_wrapper<U> > >::type
partial_flatten_single_mdcaw(MDCAW const& mdcaw)
{
  auto pdc = std::get<index>(mdcaw._tpdcs);
  return std::make_tuple( data_channel_access_wrapper<U>(*pdc, mdcaw._dir) );
}

template<int index, int remaining, typename MDCAW, typename U, typename ...Us>
typename std::enable_if< (remaining > 1),
                         std::tuple< data_channel_access_wrapper<U>,
                         data_channel_access_wrapper<Us>... > >::type
partial_flatten_single_mdcaw(MDCAW const& mdcaw)
{
  auto pdc = std::get<index>(mdcaw._tpdcs);
  return std::tuple_cat(
           std::make_tuple( data_channel_access_wrapper<U>(*pdc, mdcaw._dir) ),
           partial_flatten_single_mdcaw<index+1,
                                        remaining-1,
                                        MDCAW,
                                        Us...>
                                       (mdcaw) );
}


  /// Converts MDCAW<T1, T2, ...> object into tuple< DCAW<T1>, DCAW<T2>, ... >
template<typename T, typename ...Ts>
std::tuple< data_channel_access_wrapper<T>,
            data_channel_access_wrapper<Ts>... >
flatten_single_mdcaw(
    multiple_data_channel_access_wrapper<T, Ts...> const& mdcaw)
{
  return partial_flatten_single_mdcaw<
                0,
                sizeof...(Ts)+1,
                multiple_data_channel_access_wrapper<T, Ts...>,
                T, Ts...
          >(mdcaw);
}

} //namespace internal
} //namespace mare

////

#ifdef _MSC_VER
  /// The following file is auto-generated by
  /// mare/scripts/genvs2013sdfworkaround.pl
#include <mare/internal/sdf/vs2013workaround.hh>

#else //no _MSC_VER ==> hopefully gcc

namespace mare {
namespace internal {

  /// Type combination functionality, with tuples used as type container names
  ///
  /// Conventions:
  /// TT  = tuple<T1, T2>
  /// TTT = tuple< tuple<T1, T2>, tuple<T3>, ... >

  /// This tuple-based type machinery infers return type, as gcc
  /// is unable to infer return type of flattened expression when
  /// flattening a sequence of MDCAWs to a sequence DCAWs.
  ///
  /// See flatten_multiple_mdcaws().


  /// Helper for tuple_type_combiner.
  /// Flattens TTT = tuple< tuple<T1, T2>, tuple<T3>, ... >
  /// into tuple<T1, T2, T3, ...>
template<int index, typename TTT>
struct tuple_of_tuple_flatten {
  typename tuple_of_tuple_flatten<index-1, TTT>::flattened_TT prefix_elems;
  typename std::tuple_element<index, TTT>::type               indexed_elem;

  typedef decltype( std::tuple_cat( prefix_elems, indexed_elem ) )
          flattened_TT;
};

template<typename TTT>
struct tuple_of_tuple_flatten<0, TTT> {
  typedef typename std::tuple_element<0, TTT>::type
          flattened_TT;
};

  /// Instantiating
  ///     tuple_type_combiner< tuple<T1, T2>, tuple<T3>, ..., tuple<Tn-1, Tn> >
  /// produces
  ///     ::type_cat => tuple<T1, T2, T3, ... Tn>
template<typename ...TTs>
struct tuple_type_combiner {
  typedef std::tuple<TTs...> tuple_of_TTs;

  typedef typename tuple_of_tuple_flatten<sizeof...(TTs)-1,
                                          tuple_of_TTs>::flattened_TT
          type_cat;
  /// Add other combination/transformation functionality besides concatenation?
};

template<typename TT>
struct tuple_type_combiner<TT> {
  typedef TT
          type_cat;
};

  /// Helper for tuple_type_apply_wrapper
template<int index, template<typename> class X, typename TT>
struct tuple_type_apply_wrapper_helper {
  typename tuple_type_apply_wrapper_helper<index-1,
                                           X,
                                           TT>::type_wrapped  prefix_TXTs;
  std::tuple< X< typename std::tuple_element<index,
                                             TT>::type > >    last_TXT;

  typedef decltype(
            std::tuple_cat( prefix_TXTs, last_TXT ) )
          type_wrapped;
};

template<template<typename> class X, typename TT>
struct tuple_type_apply_wrapper_helper<0, X, TT> {
  std::tuple< X< typename std::tuple_element<0, TT>::type > > last_TXT;

  typedef decltype(
            last_TXT )
          type_wrapped;
};

  /// Instantiating
  ///    tuple_type_apply_wrapper< X, TT=tuple<T1, T2, ..., Tn> >
  /// produces
  ///    ::type_wrapped == tuple< X<T1>, X<T2>, ..., X<Tn> >
  ///
  /// Use case:
  /// with X = template<typename> class data_channel_access_wrapper
  /// produces tuple< DCAW<T1>, DCAW<T2>, ..., DCAW<Tn> >

template<template<typename> class X, typename TT>
struct tuple_type_apply_wrapper {
  typedef typename tuple_type_apply_wrapper_helper<
                                                  std::tuple_size<TT>::value-1,
                                                  X,
                                                  TT
                                                  >::type_wrapped
          type_wrapped;
};

////

  ///  Note:
  ///    MDCAW<T1, T2>::collection_sig_type == std::tuple<T1, T2>
  ///    MDCAW<T3     ::collection_sig_type == std::tuple<T3>
  ///    etc.
  ///
  ///  Instantiating
  ///    collection_sig_type_combiner< MDCAW<T1, T2>, MDCAW<T3>, ... >
  ///  produces
  ///    ::type == std::tuple<T1, T2, T3, ...>

template<typename ...MDCAWs>
struct collection_sig_type_combiner;

template<typename MDCAW1, typename MDCAW2, typename ...MDCAWs>
struct collection_sig_type_combiner<MDCAW1, MDCAW2, MDCAWs...> {
  typedef
    typename tuple_type_combiner<typename MDCAW1::collection_sig_type,
                                 typename
                                   collection_sig_type_combiner<MDCAW2,
                                                                MDCAWs...>
                                   ::type
                                >::type_cat
    type;
};

template<typename MDCAW1>
struct collection_sig_type_combiner<MDCAW1> {
  typedef
    typename MDCAW1::collection_sig_type
    type;
};

  /// Instantiating
  ///    flattened_tdcaw_type_from_mdcaws< MDCAW<T1, T2>,
  ///                                      MDCAW<T3>,
  ///                                      MDCAW<T4, T5, T6> >
  /// produces
  ///    ::type ==
  ///      tuple< DCAW<T1>, DCAW<T2>, DCAW<T3>, DCAW<T4>, DCAW<T5>, DCAW<T6> >

template<typename ...MDCAWs>
struct flattened_tdcaw_type_from_mdcaws {
  typedef
    typename tuple_type_apply_wrapper<
      data_channel_access_wrapper,
      typename collection_sig_type_combiner<MDCAWs...>::type
    >::type_wrapped
    type;
};


  /// flatten_multiple_mdcaws:
  /// Converts a parameter list of MDCAW objects into a flattened
  /// tuple of DCAW obejcts of corresponding user-data-types.
template<typename MDCAW1, typename MDCAW2, typename ...MDCAWs>
typename flattened_tdcaw_type_from_mdcaws<MDCAW1, MDCAW2, MDCAWs...>::type
flatten_multiple_mdcaws(MDCAW1 const& mdcaw1,
                        MDCAW2 const& mdcaw2,
                        MDCAWs const&... mdcaws)
{
  return std::tuple_cat(
    flatten_multiple_mdcaws(mdcaw1),
    flatten_multiple_mdcaws(mdcaw2, mdcaws...));
}

template<typename ...Ts>
std::tuple< data_channel_access_wrapper<Ts>... >
flatten_multiple_mdcaws(
    multiple_data_channel_access_wrapper<Ts...> const& mdcaw)
{
  return flatten_single_mdcaw(mdcaw);
}

} //namespace internal
} //namespace mare

#endif //_MSC_VER

////

namespace mare {
namespace internal {

template<typename A>
std::tuple<A*> make_address_of_tuple(A& a)
{
  return std::make_tuple(&a);
}

template<typename A, typename ...As>
std::tuple<A*, As*...> make_address_of_tuple(A& a, As&... as)
{
  return std::tuple_cat(std::make_tuple(&a), make_address_of_tuple(as...));
}

////

  /// Channel push/pop Functionality
  ///  (please also read about SDF Node Policies in sdfnodepolicy.hh)
  ///
  /// pop_inputs() and push_outputs() pop/push a collection of channels,
  ///   checking each channel whether it is an input or output channel.
  /// Variants of pop_inputs() and push_outputs() are provided to work
  /// with every choice of node_fn_policy.

template<size_t index, typename ...Ts>
typename std::enable_if< (index == 0), bool>::type
pop_inputs_helper(
  std::tuple< data_channel<Ts>*... >& pdc_tuple,
  std::vector<direction> const&       vdir,
  std::tuple<Ts...>&                  var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::in) {
    index_channel_needs_retry =
      !pop_value( *(std::get<index>(pdc_tuple)),
                       std::get<index>(var_tuple) );
  }
  return index_channel_needs_retry;
}

template<size_t index, typename ...Ts>
typename std::enable_if< (index > 0), bool>::type
pop_inputs_helper(
  std::tuple< data_channel<Ts>*... >& pdc_tuple,
  std::vector<direction> const&       vdir,
  std::tuple<Ts...>&                  var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::in) {
    index_channel_needs_retry =
      !pop_value( *(std::get<index>(pdc_tuple)),
                       std::get<index>(var_tuple) );
  }

  bool remaining_channels_need_retry =
    pop_inputs_helper<index-1, Ts...>(pdc_tuple, vdir, var_tuple);

  return index_channel_needs_retry || remaining_channels_need_retry;
}

  /// len_Ts used instead of std::enable_if as workaround to
  /// VS2013 limitations
template<std::size_t len_Ts, typename ...Ts>
bool
pop_inputs(
  data_channel_parameters<Ts...>& datachannel_cr,
  std::vector<direction> const&   vdir,
  std::tuple<Ts...>&              var_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizeof...(Ts),
                       "vdir has improper length");
  return pop_inputs_helper<sizeof...(Ts)-1,
                           Ts...>(datachannel_cr._channel_handles,
                                  vdir,
                                  var_tuple);
}

template<>
bool
pop_inputs<0>(
  data_channel_parameters<>&      datachannel_cr,
  std::vector<direction> const&   vdir,
  std::tuple<>&                   var_tuple);

////

template<size_t index, typename ...Ts>
typename std::enable_if< (index == 0), bool>::type
pop_inputs_helper(
  std::vector<channel*>         vchannels,
  std::vector<direction> const& vdir,
  std::tuple<Ts...>&            var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::in) {
    index_channel_needs_retry =
      !pop_buf( vchannels[index], &(std::get<index>(var_tuple)) );
  }
  return index_channel_needs_retry;
}

template<size_t index, typename ...Ts>
typename std::enable_if< (index > 0), bool>::type
pop_inputs_helper(
  std::vector<channel*>         vchannels,
  std::vector<direction> const& vdir,
  std::tuple<Ts...>&            var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::in) {
    index_channel_needs_retry =
      !pop_buf( vchannels[index], &(std::get<index>(var_tuple)) );
  }

  bool remaining_channels_need_retry =
    pop_inputs_helper<index-1, Ts...>(vchannels, vdir, var_tuple);

  return index_channel_needs_retry || remaining_channels_need_retry;
}

  /// Spurious len_Ts added to maintain template parameter-list
  /// consistent across all versions of pop_inputs()
template<std::size_t len_Ts, typename ...Ts>
bool pop_inputs(
  sized_channel_parameters<Ts...>& sizedchannel_cr,
  std::vector<direction> const&    vdir,
  std::tuple<Ts...>&               var_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizeof...(Ts),
                       "vdir has improper length");
  return pop_inputs_helper<sizeof...(Ts)-1,
                           Ts...>(sizedchannel_cr._channel_handles,
                                  vdir,
                                  var_tuple);
}


////

  /// Spurious len_Ts added to maintain template parameter-list
  /// consistent across all versions of pop_inputs()
template<std::size_t len_Ts, typename ...Ts>
bool pop_inputs(
  sized_channel_parameters<Ts...>& sizedchannel_cr,
  std::vector<direction> const&    vdir,
  std::tuple<node_channels>&       ncs_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizedchannel_cr._channel_handles.size(),
                       "vdir has improper length");

  auto& ncs = std::get<0>(ncs_tuple);
  auto& ncs_vdir      = node_channels_accessor::access_vdir     (ncs);
  auto& ncs_velemsize = node_channels_accessor::access_velemsize(ncs);
  auto& ncs_vbuffer   = node_channels_accessor::access_vbuffer  (ncs);
  if(ncs_vbuffer.size() == 0) {
    ncs_vdir      = vdir;
    ncs_velemsize = sizedchannel_cr._velemsize;
    ncs_vbuffer   = sizedchannel_cr._vbuffer;
  }

  bool any_channel_needs_retry = false;
  for(std::size_t index=0; index<vdir.size(); index++) {
    bool index_channel_needs_retry = false;
    if(vdir[index] == direction::in) {
      index_channel_needs_retry =
        !pop_buf( sizedchannel_cr._channel_handles[index],
                             ncs_vbuffer[index] );
    }
    any_channel_needs_retry = any_channel_needs_retry ||
                              index_channel_needs_retry;
  }

  return any_channel_needs_retry;
}


////

template<size_t index, typename ...Ts>
typename std::enable_if< (index == 0), bool>::type
push_outputs_helper(
  std::tuple< data_channel<Ts>*... >& pdc_tuple,
  std::vector<direction> const&       vdir,
  std::tuple<Ts...>&                  var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::out) {
    index_channel_needs_retry =
      !push_value( *(std::get<index>(pdc_tuple)), std::get<index>(var_tuple) );
  }
  return index_channel_needs_retry;
}

template<size_t index, typename ...Ts>
typename std::enable_if< (index > 0), bool>::type
push_outputs_helper(
  std::tuple< data_channel<Ts>*... >& pdc_tuple,
  std::vector<direction> const&       vdir,
  std::tuple<Ts...>&                  var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::out) {
    index_channel_needs_retry =
      !push_value( *(std::get<index>(pdc_tuple)), std::get<index>(var_tuple) );
  }

  bool remaining_channels_need_retry =
    push_outputs_helper<index-1, Ts...>(pdc_tuple, vdir, var_tuple);

  return index_channel_needs_retry || remaining_channels_need_retry;
}

  /// len_Ts used instead of std::enable_if as workaround to
  /// VS2013 limitations
template<std::size_t len_Ts, typename ...Ts>
bool
push_outputs(
  data_channel_parameters<Ts...>& datachannel_cr,
  std::vector<direction> const&   vdir,
  std::tuple<Ts...>&              var_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizeof...(Ts),
                       "vdir has improper length");
  return push_outputs_helper<sizeof...(Ts)-1,
                             Ts...>(datachannel_cr._channel_handles,
                                    vdir,
                                    var_tuple);
}

template<>
bool
push_outputs<0>(
  data_channel_parameters<>&      datachannel_cr,
  std::vector<direction> const&   vdir,
  std::tuple<>&                   var_tuple);

////

template<size_t index, typename ...Ts>
typename std::enable_if< (index == 0), bool>::type
push_outputs_helper(
  std::vector<channel*>         vchannels,
  std::vector<direction> const& vdir,
  std::tuple<Ts...>&            var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::out) {
    index_channel_needs_retry =
      !push_buf( vchannels[index], &(std::get<index>(var_tuple)) );
  }
  return index_channel_needs_retry;
}

template<size_t index, typename ...Ts>
typename std::enable_if< (index > 0), bool>::type
push_outputs_helper(
  std::vector<channel*>         vchannels,
  std::vector<direction> const& vdir,
  std::tuple<Ts...>&            var_tuple)
{
  bool index_channel_needs_retry = false;
  if(vdir[index] == direction::out) {
    index_channel_needs_retry =
      !push_buf( vchannels[index], &(std::get<index>(var_tuple)) );
  }

  bool remaining_channels_need_retry =
    push_outputs_helper<index-1, Ts...>(vchannels, vdir, var_tuple);

  return index_channel_needs_retry || remaining_channels_need_retry;
}

  /// Spurious len_Ts added to maintain template parameter-list
  /// consistent across all versions of push_outputs()
template<std::size_t len_Ts, typename ...Ts>
bool
push_outputs(
  sized_channel_parameters<Ts...>& sizedchannel_cr,
  std::vector<direction> const&    vdir,
  std::tuple<Ts...>&               var_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizeof...(Ts),
                       "vdir has improper length");
  return push_outputs_helper<sizeof...(Ts)-1,
                             Ts...>(sizedchannel_cr._channel_handles,
                                    vdir,
                                    var_tuple);
}

////


  /// Spurious len_Ts added to maintain template parameter-list
  /// consistent across all versions of push_outputs()
template<std::size_t len_Ts, typename ...Ts>
bool
push_outputs(
  sized_channel_parameters<Ts...>& sizedchannel_cr,
  std::vector<direction> const&    vdir,
  std::tuple<node_channels>&       ncs_tuple)
{
  MARE_INTERNAL_ASSERT(vdir.size() == sizedchannel_cr._channel_handles.size(),
                       "vdir has improper length");

  auto& ncs = std::get<0>(ncs_tuple);
  auto& ncs_vdir      = node_channels_accessor::access_vdir     (ncs);
  auto& ncs_velemsize = node_channels_accessor::access_velemsize(ncs);
  auto& ncs_vbuffer   = node_channels_accessor::access_vbuffer  (ncs);
  if(ncs_vbuffer.size() == 0) {
    ncs_vdir      = vdir;
    ncs_velemsize = sizedchannel_cr._velemsize;
    ncs_vbuffer   = sizedchannel_cr._vbuffer;
  }

  bool any_channel_needs_retry = false;
  for(std::size_t index=0; index<vdir.size(); index++) {
    bool index_channel_needs_retry = false;
    if(vdir[index] == direction::out) {
      index_channel_needs_retry =
        !push_buf( sizedchannel_cr._channel_handles[index],
                   ncs_vbuffer[index] );
    }
    any_channel_needs_retry = any_channel_needs_retry ||
                              index_channel_needs_retry;
  }
  return any_channel_needs_retry;
}


  /// Node Function Application
  ///
  /// apply(): applies the node-function to a tuple of channel data values
  ///           holding the input and output values.
  ///
  /// Note: the untyped-data case is handled by the node-function taking
  /// exactly one parameter, with the parameter allowing introspection over
  /// the input and output data values (see node_channels in sdfpr.hh):
  ///      f(node_channels& ncs)

template<typename NodeFn,
         size_t last_unpacked_index,
         typename ...Ts,
         typename ...Unpacked>
typename std::enable_if<(last_unpacked_index == 0), void>::type
apply_helper(NodeFn f, std::tuple<Ts...>& , Unpacked&... us)
{
  f(us...);
}

template<typename NodeFn,
         size_t last_unpacked_index,
         typename ...Ts,
         typename ...Unpacked>
typename std::enable_if<(last_unpacked_index > 0), void>::type
apply_helper(NodeFn f, std::tuple<Ts...>& var_tuple, Unpacked&... us)
{
  apply_helper<NodeFn, last_unpacked_index-1>
              (f,
               var_tuple,
               std::get<last_unpacked_index-1>(var_tuple),
               us...);
}


template<typename NodeFn, typename ...Ts>
void apply(NodeFn f, std::tuple<Ts...>& var_tuple)
{
  apply_helper<NodeFn, sizeof...(Ts), Ts...>(f, var_tuple);
}

////

std::size_t gen_node_debug_id(sdf_graph_ptr g);


  /// sdf_node:
  /// abstraction for SDF node exposed to user via the API

class sdf_node {
protected:
  sdf_node() {}

public:
  virtual sdf_graph_ptr get_graph_ptr() const = 0;
  virtual ~sdf_node() {}

  MARE_DELETE_METHOD(sdf_node(sdf_node const&));
  MARE_DELETE_METHOD(sdf_node& operator=(sdf_node const&));
  MARE_DELETE_METHOD(sdf_node(sdf_node&&));
  MARE_DELETE_METHOD(sdf_node& operator=(sdf_node&&));
};

  /// sdf_node_common:
  /// internal non-templated concrete node representation
  /// implementing the storage and interfaces needed by the runtime.
  ///
  /// - method iter_work(): executes the node-function, pops/pushes channels,
  ///                       allows interruption of node and re-execution of a
  ///                       previously interruped node.

class sdf_node_common : public sdf_node {
protected:
  sdf_node_common(sdf_graph_ptr g, std::vector<direction> const& vdir) :
    sdf_node(),
    _g(g),
    _debug_id(gen_node_debug_id(g)),
    _vdir(vdir),
    _vchannels(),
    _was_interrupted(false),
    _applied_f_before_interruption(false) { }

  MARE_DELETE_METHOD(sdf_node_common(sdf_node_common const&));
  MARE_DELETE_METHOD(sdf_node_common& operator=(sdf_node_common const&));
  MARE_DELETE_METHOD(sdf_node_common(sdf_node_common&&));
  MARE_DELETE_METHOD(sdf_node_common& operator=(sdf_node_common&&));

  sdf_graph_ptr _g;
  std::size_t const _debug_id;

  std::vector<direction> _vdir;
  std::vector<channel*>  _vchannels;

  /// see description under sdf_node_typed::iter_work()
  bool _was_interrupted;
  bool _applied_f_before_interruption;

public:
  virtual sdf_graph_ptr get_graph_ptr() const
  {
    return const_cast<sdf_graph_ptr>(_g);
  }

  inline std::size_t get_debug_id() const
  {
    return _debug_id;
  }

  std::vector<channel*> const& get_vchannels() const
  {
    return _vchannels;
  }

  inline bool get_was_interrupted() const
  {
    return _was_interrupted;
  }

  inline bool get_applied_f_before_interruption() const
  {
    return _applied_f_before_interruption;
  }

  /// returns true if interrupted
  virtual bool iter_work(volatile bool* p_interrupt_immediately) = 0;

  virtual ~sdf_node_common() {}
};

  /// sdf_node_typed: templated derived type instantiated by
  ///    create_sdf_node() variants. Implements compile-time
  ///    type-safety via policies.
  ///
  /// See SDF Node Policies in sdfnodepolicy.hh

template<
  template<typename ...> class node_fn_policy,
  template<typename ...> class channel_repr_policy,
  template<typename ...> class channel_init_policy,
  typename ...Ts
>
class sdf_node_typed : public sdf_node_common {
public:
  typename node_fn_policy<Ts...>::ftype             _f;
  typename node_fn_policy<Ts...>::valtype           _values;

  typename channel_repr_policy<Ts...>::channel_repr _cr;

  sdf_node_typed(
    sdf_graph_ptr                                   g,
    typename node_fn_policy<Ts...>::ftype&          f,
    std::vector<direction> const&                   vdir,
    typename channel_init_policy<Ts...>::init_type& channels_initializer
  ) :
    sdf_node_common(g, vdir),
    _f(f),
    _values(),
    _cr()
  {
    _vchannels = _cr.init(channels_initializer);

    MARE_INTERNAL_ASSERT(_vdir.size() == _vchannels.size(),
                         "vdir has improper length");
  }

  virtual bool iter_work(volatile bool* p_interrupt_immediately) {
  /// _was_interrupted ==> was any of pop, apply or push interrupted in the
  ///    previous invocation of iter_work().
  /// _applied_f_before_interruption (defined here iff _was_interrupted==true)
  ///    flags whether f was applied previously during interrupted iter_work().

    bool pop_inputs_needs_retry =
      pop_inputs<sizeof...(Ts)>(_cr, _vdir, _values);
      /// interrupted and resumed internally

    bool node_interrupted_immediately = (p_interrupt_immediately != 0 &&
                                         *p_interrupt_immediately);
    if(node_interrupted_immediately) {
      if(!_was_interrupted)
        _applied_f_before_interruption = false;
      /// else: may have already applied f before previous interruption, retain
    } else if(pop_inputs_needs_retry) {
      /// assumption: monotonic change, pop_inputs_needs_retry=true to false
      ///    over retries
      _applied_f_before_interruption = false;
    } else if(!_was_interrupted || !_applied_f_before_interruption) {
      apply(_f, _values);
      _applied_f_before_interruption = true;
    }
    /// else: was interrupted in previous invocation, but after applying f

    bool push_outputs_needs_retry = false;
    if(_applied_f_before_interruption)
    {
      push_outputs_needs_retry =
        push_outputs<sizeof...(Ts)>(_cr, _vdir, _values);
        /// interrupted and resumed internally
    }

    _was_interrupted = pop_inputs_needs_retry ||
                       node_interrupted_immediately ||
                       !_applied_f_before_interruption ||
                       push_outputs_needs_retry;
    return _was_interrupted;
  }

  MARE_DELETE_METHOD(sdf_node_typed(sdf_node_typed const&));
  MARE_DELETE_METHOD(sdf_node_typed operator=(sdf_node_typed const&));
  MARE_DELETE_METHOD(sdf_node_typed(sdf_node_typed&&));
  MARE_DELETE_METHOD(sdf_node_typed operator=(sdf_node_typed&&));
};

////

  /// Connects up a node to in and out channels.
  /// Helper functionality when a node is being created.
void set_all_src_dst(
  sdf_node_common*                sdf_node,
  std::vector<direction> const&   vdir,
  std::vector<std::size_t> const& vsizes,
  std::vector<channel*> const&    vchannels);

  /// Adds a newly created node to its graph.
  /// Helper functionality when a node is being created.
void add_sdf_node_to_graph(sdf_graph_ptr g, sdf_node_common* n);


////


  /// Given a parameter list of objects
  ///   DCAW<T1>, DCAW<T2>, DCAW<T3>, ..., DCAW<Tn>
  /// extracts:
  ///    vdir = vector containing in/out channel directions
  ///           for the channel-bindings DCAW<T1> ... DCAW<Tn>
  /// returns:
  ///    tuple of pointers to the corresponding data_channel objects
template<std::size_t len_Ts, typename T, typename ...Ts>
typename std::enable_if<len_Ts >= 1,
                        std::tuple< data_channel<T>*, data_channel<Ts>*... >
                       >::type
extract_data_channel_tuple_and_vdir(
  std::vector<direction>&            vdir,
  data_channel_access_wrapper<T>     dcaw,
  data_channel_access_wrapper<Ts>... dcaws)
{
  vdir.push_back(dcaw._dir);
  return std::tuple_cat( std::make_tuple(dcaw._pdc),
                         extract_data_channel_tuple_and_vdir<len_Ts-1>
                                                            (vdir, dcaws...) );
}

template<std::size_t len_Ts, typename ...Ts>
typename std::enable_if<len_Ts == 0,
                        std::tuple<>
                       >::type
extract_data_channel_tuple_and_vdir(
  std::vector<direction>& )
{
  return std::make_tuple<>();
}

////

  /// Helper routine for creating a node when the connecting channels
  /// are specified as a parameter list of DCAWs.
template<
  template<typename ...> class node_fn_policy,
  template<typename ...> class channel_repr_policy,
  typename ...Ts
>
sdf_node_ptr create_sdf_node_helper(
  sdf_graph_ptr                         g,
  typename node_fn_policy<Ts...>::ftype f,
  data_channel_access_wrapper<Ts>...    dcaws)
{
  std::vector<direction> vdir;

  auto tp_data_channel = extract_data_channel_tuple_and_vdir<sizeof...(Ts)>
                                                            (vdir, dcaws...);

  auto* n = new sdf_node_typed<
                                node_fn_policy,
                                channel_repr_policy,
                                channel_init_policy__data_channel_tuple,
                                Ts...
                               >(g, f, vdir, tp_data_channel);

  sdf_node_common* sdf_node = dynamic_cast<sdf_node_common*>(n);
  MARE_INTERNAL_ASSERT(sdf_node != nullptr,
                       "dynamic cast should not have failed");

  std::vector<size_t> vsizes;
  for(auto c : n->get_vchannels())
    vsizes.push_back( c->get_elem_size() );

  set_all_src_dst(sdf_node, vdir, vsizes, n->get_vchannels());

  add_sdf_node_to_graph(g, sdf_node);

  return dynamic_cast<sdf_node_ptr>(sdf_node);
}



template<typename ...Ts>
sdf_node_ptr sub_create_sdf_node(
  sdf_graph_ptr g,
  void (* f)(Ts&... ts),
  data_channel_access_wrapper<Ts>... dcaws)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__func_pointer,
                              internal::channel_repr_policy__data_channel,
                              Ts...
                             >(g, f, dcaws...);
}

template<typename NodeFn, typename ...Ts>
typename std::enable_if<!std::is_function<NodeFn>::value, sdf_node_ptr>::type
sub_create_sdf_node(
  sdf_graph_ptr g,
  NodeFn f,
  data_channel_access_wrapper<Ts>... dcaws)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__std_function,
                              internal::channel_repr_policy__data_channel,
                              Ts...
                             >(g, f, dcaws...);
}

template<typename ...Ts>
sdf_node_ptr sub_create_sdf_node(
  sdf_graph_ptr g,
  void (* f)(node_channels&),
  data_channel_access_wrapper<Ts>... dcaws)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__programatic_function,
                              internal::channel_repr_policy__sized_channel,
                              Ts...
                             >(g, f, dcaws...);
}


  /// apply_tuple_to_create_sdf_node():
  /// invoked by the top-level create_sdf_node() call to match against the
  /// canonical sub_create_sdf_node() calls to find the best matching
  /// node policy and apply to flattened channel arguments.
  ///
  /// apply_tuple_to_create_sdf_node(g, f, tuple( dcaw1, dcaw2, ... dcawn) )
  /// invokes a sub_create_sdf_node() suitable for the node policy of f:
  ///    sub_create_sdf_node(g, f, dcaw1, dcaw2, ..., dcawn)

template<int index, typename NodeFn, typename ...Ts, typename ...Us>
typename std::enable_if<(index == -1), sdf_node_ptr>::type
apply_tuple_to_create_sdf_node_helper(
  sdf_graph_ptr g,
  NodeFn f,
  std::tuple< data_channel_access_wrapper<Ts>... > const& ,
  Us&... us)
{
  return internal::sub_create_sdf_node(g, f, us...);
}

template<int index, typename NodeFn, typename ...Ts, typename ...Us>
typename std::enable_if<(index >= 0), sdf_node_ptr>::type
apply_tuple_to_create_sdf_node_helper(
  sdf_graph_ptr g,
  NodeFn f,
  std::tuple< data_channel_access_wrapper<Ts>... > const& tdcaw,
  Us&... us)
{
  typedef typename std::tuple_element<
                            index,
                            std::tuple< data_channel_access_wrapper<Ts>... >
                           >::type
          index_dcaw_type;

  index_dcaw_type& index_dcaw = const_cast<index_dcaw_type&>
                                          ( std::get<index>(tdcaw) );

  return apply_tuple_to_create_sdf_node_helper<
                      index-1,
                      NodeFn
          >(g, f, tdcaw, index_dcaw, us...);
}

template<typename NodeFn, typename ...Ts>
sdf_node_ptr apply_tuple_to_create_sdf_node(
  sdf_graph_ptr g,
  NodeFn f,
  std::tuple< data_channel_access_wrapper<Ts>... > const& tdcaw)
{
  return apply_tuple_to_create_sdf_node_helper<int(sizeof...(Ts)-1),
                                               NodeFn,
                                               Ts...>
                                              (g, f, tdcaw);
}



  /// is_MDCAW():
  /// the "canonical" variants of create_sdf_node() accept a sequence of
  /// data_channel_access_wrapper objects. However, there is single variant
  /// of create_sdf_node() that accepts a sequence of
  /// multiple_data_channel_access_wrapper objects, which are flattened into
  /// a sequence of data_channel_access_wrapper objects and passed to one of
  /// the canonical variants of create_sdf_node().
  ///
  /// Unfortunately, when the multiple_data_channel_access_wrapper variant
  /// of create_sdf_node() calls a canonical variant of create_sdf_node
  /// (with parameters flattened to data_channel_access_wrapper sequence),
  /// the compiler sometimes attempts to recursively match with only the
  /// multiple_data_channel_access_wrapper variant of create_sdf_node().
  /// To fix, we explictly check if the parameter-list is of
  /// multiple_data_channel_access_wrapper objects before allowing that
  /// variant to match at compile-time. Hence, the recursive call to
  /// create_sdf_node() will fail the is_MDCAW test, and compiler will
  /// instead attempt to match against the canonical variants.

template<typename ...possible_MDCAWs>
struct is_MDCAW;

template<typename possible_MDCAW>
struct is_MDCAW<possible_MDCAW> {
  typedef char positive;
  typedef long negative;

  template <typename M> static
    positive test( typename M::collection_sig_type* );
  template <typename M> static
    negative test( ... );

  enum { value = sizeof(test<possible_MDCAW>(0)) == sizeof(positive) };
};

template<typename possible_MDCAW1,
         typename possible_MDCAW2,
         typename ...possible_MDCAWs>
struct is_MDCAW<possible_MDCAW1, possible_MDCAW2, possible_MDCAWs...> {
  enum { value = (is_MDCAW<possible_MDCAW1>::value &&
                  is_MDCAW<possible_MDCAW2,
                  possible_MDCAWs...>::value) };
};

} //namespace internal
} //namespace mare


namespace mare {

  /// create_sdf_node():
  /// top-level user-API call accepting parameter list of MDCAWs
  /// produced using with_inputs() and with_outputs().
  /// See documentation in sdf.hh
template<typename Body, typename ...IOC_GROUPS>
typename std::enable_if<internal::is_MDCAW<IOC_GROUPS...>::value,
                        sdf_node_ptr>::type
create_sdf_node(
  sdf_graph_ptr g,
  Body&& body,
  IOC_GROUPS const&... io_channels_groups)
{
#ifdef _MSC_VER
  auto       tdcaw = internal::flatten_multiple_mdcaws(io_channels_groups...);
#else
  typename internal::flattened_tdcaw_type_from_mdcaws<IOC_GROUPS...>::type
             tdcaw = internal::flatten_multiple_mdcaws(io_channels_groups...);
#endif
  /// tdcaw = tuple of data_channel_access_wrapper
  ///   -- from flattened io_channels_groups
  return internal::apply_tuple_to_create_sdf_node(g, body, tdcaw);
}


} //namespace mare

////

namespace mare {
namespace internal {

  /// Helper routine for creating a node when the connecting channels
  /// are specified as a vector of bindings of
  /// direction & non-templated channel-pointer
template<
  template<typename ...> class node_fn_policy,
  template<typename ...> class channel_repr_policy,
  typename ...Ts
>
sdf_node_ptr create_sdf_node_helper(
  sdf_graph_ptr                                   g,
  typename node_fn_policy<Ts...>::ftype           f,
  std::vector< std::tuple<direction, channel*> >& v_dir_channels)
{
  std::vector<direction> vdir;
  std::vector<channel*> vchannels;

  for(auto dc : v_dir_channels) {
    vdir     .push_back(std::get<0>(dc));
    vchannels.push_back(std::get<1>(dc));
  }

  auto* n = new sdf_node_typed<
                                node_fn_policy,
                                channel_repr_policy,
                                channel_init_policy__channel_vector,
                                Ts...
                               >(g, f, vdir, vchannels);

  sdf_node_common* sdf_node = dynamic_cast<sdf_node_common*>(n);
  MARE_INTERNAL_ASSERT(sdf_node != nullptr,
                       "dynamic cast should not have failed");

  std::vector<size_t> vsizes;
  for(auto c : n->get_vchannels())
    vsizes.push_back( c->get_elem_size() );

  set_all_src_dst(sdf_node, vdir, vsizes, n->get_vchannels());

  add_sdf_node_to_graph(g, sdf_node);

  return dynamic_cast<sdf_node_ptr>(sdf_node);
}


template<typename ...Ts>
sdf_node_ptr sub_create_sdf_node(
  sdf_graph_ptr g,
  void (* f)(Ts&... ts),
  std::vector< std::tuple<direction, channel*> >& v_dir_channels)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__func_pointer,
                              internal::channel_repr_policy__sized_channel,
                              Ts...
                             >(g, f, v_dir_channels);
}

template<typename NodeFn, typename ...Ts>
typename std::enable_if<!std::is_function<NodeFn>::value, sdf_node_ptr>::type
sub_create_sdf_node(
  sdf_graph_ptr g,
  NodeFn f,
  std::vector< std::tuple<direction, channel*> >& v_dir_channels)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__std_function,
                              internal::channel_repr_policy__sized_channel,
                              Ts...
                             >(g, f, v_dir_channels);
}

} //namespace internal

  /// create_sdf_node():
  /// top-level user-API call allowing a programmatically
  /// constructed vector of non-templated channels to
  /// connect with a non-templated introspecting body.
  /// See documentation in sdfpr.hh
inline
sdf_node_ptr create_sdf_node(
  sdf_graph_ptr g,
  void (* body)(node_channels&),
  std::vector<tuple_dir_channel>& v_dir_channels)
{
  return internal::create_sdf_node_helper<
                              internal::node_fn_policy__programatic_function,
                              internal::channel_repr_policy__sized_channel
                             >(g, body, v_dir_channels);
}

  /// create_sdf_node():
  /// top-level user-API call allowing a programmatically
  /// constructed vector of non-templated channels to
  /// connect with a body of an arbitrary node policy.
  /// See documentation in sdfpr.hh
template<typename Body>
sdf_node_ptr create_sdf_node(
  sdf_graph_ptr g,
  Body&& body,
  std::vector<tuple_dir_channel>& v_dir_channels)
{
  return internal::sub_create_sdf_node(g, body, v_dir_channels);
}

} //namespace mare

namespace mare {

  /// See sdf.hh
class sdf_graph_query_info;

  /// See sdf.hh
std::string to_string(sdf_graph_query_info const& info);

template<typename OStream>
OStream& operator<<(OStream& os, sdf_graph_query_info const& info)
{
  os << to_string(info);
  return os;
}


} //namespace mare
